using System;
using System.Runtime.InteropServices;

/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

namespace java.awt
{

	using AWTAccessor = sun.awt.AWTAccessor;
	using PlatformLogger = sun.util.logging.PlatformLogger;


	/// <summary>
	/// The root event class for all AWT events.
	/// This class and its subclasses supercede the original
	/// java.awt.Event class.
	/// Subclasses of this root AWTEvent class defined outside of the
	/// java.awt.event package should define event ID values greater than
	/// the value defined by RESERVED_ID_MAX.
	/// <para>
	/// The event masks defined in this class are needed by Component subclasses
	/// which are using Component.enableEvents() to select for event types not
	/// selected by registered listeners. If a listener is registered on a
	/// component, the appropriate event mask is already set internally by the
	/// component.
	/// </para>
	/// <para>
	/// The masks are also used to specify to which types of events an
	/// AWTEventListener should listen. The masks are bitwise-ORed together
	/// and passed to Toolkit.addAWTEventListener.
	/// 
	/// </para>
	/// </summary>
	/// <seealso cref= Component#enableEvents </seealso>
	/// <seealso cref= Toolkit#addAWTEventListener
	/// </seealso>
	/// <seealso cref= java.awt.event.ActionEvent </seealso>
	/// <seealso cref= java.awt.event.AdjustmentEvent </seealso>
	/// <seealso cref= java.awt.event.ComponentEvent </seealso>
	/// <seealso cref= java.awt.event.ContainerEvent </seealso>
	/// <seealso cref= java.awt.event.FocusEvent </seealso>
	/// <seealso cref= java.awt.event.InputMethodEvent </seealso>
	/// <seealso cref= java.awt.event.InvocationEvent </seealso>
	/// <seealso cref= java.awt.event.ItemEvent </seealso>
	/// <seealso cref= java.awt.event.HierarchyEvent </seealso>
	/// <seealso cref= java.awt.event.KeyEvent </seealso>
	/// <seealso cref= java.awt.event.MouseEvent </seealso>
	/// <seealso cref= java.awt.event.MouseWheelEvent </seealso>
	/// <seealso cref= java.awt.event.PaintEvent </seealso>
	/// <seealso cref= java.awt.event.TextEvent </seealso>
	/// <seealso cref= java.awt.event.WindowEvent
	/// 
	/// @author Carl Quinn
	/// @author Amy Fowler
	/// @since 1.1 </seealso>
	public abstract class AWTEvent : EventObject
	{
		private static readonly PlatformLogger Log = PlatformLogger.getLogger("java.awt.AWTEvent");
		private sbyte[] Bdata;

		/// <summary>
		/// The event's id.
		/// @serial </summary>
		/// <seealso cref= #getID() </seealso>
		/// <seealso cref= #AWTEvent </seealso>
		protected internal int Id;

		/// <summary>
		/// Controls whether or not the event is sent back down to the peer once the
		/// source has processed it - false means it's sent to the peer; true means
		/// it's not. Semantic events always have a 'true' value since they were
		/// generated by the peer in response to a low-level event.
		/// @serial </summary>
		/// <seealso cref= #consume </seealso>
		/// <seealso cref= #isConsumed </seealso>
		protected internal bool Consumed_Renamed = false;

	   /*
	    * The event's AccessControlContext.
	    */
		[NonSerialized]
		private volatile AccessControlContext Acc = AccessController.Context;

	   /*
	    * Returns the acc this event was constructed with.
	    */
		internal AccessControlContext AccessControlContext
		{
			get
			{
				if (Acc == null)
				{
					throw new SecurityException("AWTEvent is missing AccessControlContext");
				}
				return Acc;
			}
		}

		[NonSerialized]
		internal bool FocusManagerIsDispatching = false;
		[NonSerialized]
		internal bool IsPosted;

		/// <summary>
		/// Indicates whether this AWTEvent was generated by the system as
		/// opposed to by user code.
		/// </summary>
		[NonSerialized]
		private bool IsSystemGenerated;

		/// <summary>
		/// The event mask for selecting component events.
		/// </summary>
		public const long COMPONENT_EVENT_MASK = 0x01;

		/// <summary>
		/// The event mask for selecting container events.
		/// </summary>
		public const long CONTAINER_EVENT_MASK = 0x02;

		/// <summary>
		/// The event mask for selecting focus events.
		/// </summary>
		public const long FOCUS_EVENT_MASK = 0x04;

		/// <summary>
		/// The event mask for selecting key events.
		/// </summary>
		public const long KEY_EVENT_MASK = 0x08;

		/// <summary>
		/// The event mask for selecting mouse events.
		/// </summary>
		public const long MOUSE_EVENT_MASK = 0x10;

		/// <summary>
		/// The event mask for selecting mouse motion events.
		/// </summary>
		public const long MOUSE_MOTION_EVENT_MASK = 0x20;

		/// <summary>
		/// The event mask for selecting window events.
		/// </summary>
		public const long WINDOW_EVENT_MASK = 0x40;

		/// <summary>
		/// The event mask for selecting action events.
		/// </summary>
		public const long ACTION_EVENT_MASK = 0x80;

		/// <summary>
		/// The event mask for selecting adjustment events.
		/// </summary>
		public const long ADJUSTMENT_EVENT_MASK = 0x100;

		/// <summary>
		/// The event mask for selecting item events.
		/// </summary>
		public const long ITEM_EVENT_MASK = 0x200;

		/// <summary>
		/// The event mask for selecting text events.
		/// </summary>
		public const long TEXT_EVENT_MASK = 0x400;

		/// <summary>
		/// The event mask for selecting input method events.
		/// </summary>
		public const long INPUT_METHOD_EVENT_MASK = 0x800;

		/// <summary>
		/// The pseudo event mask for enabling input methods.
		/// We're using one bit in the eventMask so we don't need
		/// a separate field inputMethodsEnabled.
		/// </summary>
		internal const long INPUT_METHODS_ENABLED_MASK = 0x1000;

		/// <summary>
		/// The event mask for selecting paint events.
		/// </summary>
		public const long PAINT_EVENT_MASK = 0x2000;

		/// <summary>
		/// The event mask for selecting invocation events.
		/// </summary>
		public const long INVOCATION_EVENT_MASK = 0x4000;

		/// <summary>
		/// The event mask for selecting hierarchy events.
		/// </summary>
		public const long HIERARCHY_EVENT_MASK = 0x8000;

		/// <summary>
		/// The event mask for selecting hierarchy bounds events.
		/// </summary>
		public const long HIERARCHY_BOUNDS_EVENT_MASK = 0x10000;

		/// <summary>
		/// The event mask for selecting mouse wheel events.
		/// @since 1.4
		/// </summary>
		public const long MOUSE_WHEEL_EVENT_MASK = 0x20000;

		/// <summary>
		/// The event mask for selecting window state events.
		/// @since 1.4
		/// </summary>
		public const long WINDOW_STATE_EVENT_MASK = 0x40000;

		/// <summary>
		/// The event mask for selecting window focus events.
		/// @since 1.4
		/// </summary>
		public const long WINDOW_FOCUS_EVENT_MASK = 0x80000;

		/// <summary>
		/// WARNING: there are more mask defined privately.  See
		/// SunToolkit.GRAB_EVENT_MASK.
		/// </summary>

		/// <summary>
		/// The maximum value for reserved AWT event IDs. Programs defining
		/// their own event IDs should use IDs greater than this value.
		/// </summary>
		public const int RESERVED_ID_MAX = 1999;

		// security stuff
		private static Field InputEvent_CanAccessSystemClipboard_Field = null;

		/*
		 * JDK 1.1 serialVersionUID
		 */
		private const long SerialVersionUID = -1825314779160409405L;

		static AWTEvent()
		{
			/* ensure that the necessary native libraries are loaded */
			Toolkit.LoadLibraries();
			if (!GraphicsEnvironment.Headless)
			{
				initIDs();
			}
			AWTAccessor.AWTEventAccessor = new AWTEventAccessorAnonymousInnerClassHelper();
		}

		private class AWTEventAccessorAnonymousInnerClassHelper : AWTAccessor.AWTEventAccessor
		{
			public AWTEventAccessorAnonymousInnerClassHelper()
			{
			}

			public virtual AWTEvent Posted
			{
				set
				{
					value.IsPosted = true;
				}
			}

			public virtual AWTEvent SystemGenerated
			{
				set
				{
					value.IsSystemGenerated = true;
				}
			}

			public virtual bool IsSystemGenerated(AWTEvent ev)
			{
				return ev.IsSystemGenerated;
			}

			public virtual AccessControlContext GetAccessControlContext(AWTEvent ev)
			{
				return ev.AccessControlContext;
			}

			public virtual sbyte[] GetBData(AWTEvent ev)
			{
				return ev.Bdata;
			}

			public virtual void SetBData(AWTEvent ev, sbyte[] bdata)
			{
				ev.Bdata = bdata;
			}

		}

		private static Field Get_InputEvent_CanAccessSystemClipboard()
		{
			lock (typeof(AWTEvent))
			{
				if (InputEvent_CanAccessSystemClipboard_Field == null)
				{
					InputEvent_CanAccessSystemClipboard_Field = AccessController.doPrivileged(new PrivilegedActionAnonymousInnerClassHelper());
				}
        
				return InputEvent_CanAccessSystemClipboard_Field;
			}
		}

		private class PrivilegedActionAnonymousInnerClassHelper : java.security.PrivilegedAction<Field>
		{
			public PrivilegedActionAnonymousInnerClassHelper()
			{
			}

			public virtual Field Run()
			{
				Field field = null;
				try
				{
					field = typeof(InputEvent).getDeclaredField("canAccessSystemClipboard");
					field.Accessible = true;
					return field;
				}
				catch (SecurityException e)
				{
					if (Log.isLoggable(PlatformLogger.Level.FINE))
					{
						Log.fine("AWTEvent.get_InputEvent_CanAccessSystemClipboard() got SecurityException ", e);
					}
				}
				catch (NoSuchFieldException e)
				{
					if (Log.isLoggable(PlatformLogger.Level.FINE))
					{
						Log.fine("AWTEvent.get_InputEvent_CanAccessSystemClipboard() got NoSuchFieldException ", e);
					}
				}
				return null;
			}
		}

		/// <summary>
		/// Initialize JNI field and method IDs for fields that may be
		/// accessed from C.
		/// </summary>
//JAVA TO C# CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		[DllImport("unknown")]
		private static extern void initIDs();

		/// <summary>
		/// Constructs an AWTEvent object from the parameters of a 1.0-style event. </summary>
		/// <param name="event"> the old-style event </param>
		public AWTEvent(Event @event) : this(@event.Target, @event.Id)
		{
		}

		/// <summary>
		/// Constructs an AWTEvent object with the specified source object and type.
		/// </summary>
		/// <param name="source"> the object where the event originated </param>
		/// <param name="id"> the event type </param>
		public AWTEvent(Object source, int id) : base(source)
		{
			this.Id = id;
			switch (id)
			{
			  case ActionEvent.ACTION_PERFORMED:
			  case ItemEvent.ITEM_STATE_CHANGED:
			  case AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED:
			  case TextEvent.TEXT_VALUE_CHANGED:
				Consumed_Renamed = true;
				break;
			  default:
		  break;
			}
		}

		/// <summary>
		/// Retargets an event to a new source. This method is typically used to
		/// retarget an event to a lightweight child Component of the original
		/// heavyweight source.
		/// <para>
		/// This method is intended to be used only by event targeting subsystems,
		/// such as client-defined KeyboardFocusManagers. It is not for general
		/// client use.
		/// 
		/// </para>
		/// </summary>
		/// <param name="newSource"> the new Object to which the event should be dispatched
		/// @since 1.4 </param>
		public virtual Object Source
		{
			set
			{
				if (Source_Renamed == value)
				{
					return;
				}
    
				Component comp = null;
				if (value is Component)
				{
					comp = (Component)value;
					while (comp != null && comp.Peer_Renamed != null && (comp.Peer_Renamed is LightweightPeer))
					{
						comp = comp.Parent_Renamed;
					}
				}
    
				lock (this)
				{
					Source_Renamed = value;
					if (comp != null)
					{
						ComponentPeer peer = comp.Peer_Renamed;
						if (peer != null)
						{
							nativeSetSource(peer);
						}
					}
				}
			}
		}

//JAVA TO C# CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		[DllImport("unknown")]
		private extern void nativeSetSource(java.awt.peer.ComponentPeer peer);

		/// <summary>
		/// Returns the event type.
		/// </summary>
		public virtual int ID
		{
			get
			{
				return Id;
			}
		}

		/// <summary>
		/// Returns a String representation of this object.
		/// </summary>
		public override String ToString()
		{
			String srcName = null;
			if (Source_Renamed is Component)
			{
				srcName = ((Component)Source_Renamed).Name;
			}
			else if (Source_Renamed is MenuComponent)
			{
				srcName = ((MenuComponent)Source_Renamed).Name;
			}
//JAVA TO C# CONVERTER WARNING: The .NET Type.FullName property will not always yield results identical to the Java Class.getName method:
			return this.GetType().FullName + "[" + ParamString() + "] on " + (srcName != null? srcName : Source_Renamed);
		}

		/// <summary>
		/// Returns a string representing the state of this <code>Event</code>.
		/// This method is intended to be used only for debugging purposes, and the
		/// content and format of the returned string may vary between
		/// implementations. The returned string may be empty but may not be
		/// <code>null</code>.
		/// </summary>
		/// <returns>  a string representation of this event </returns>
		public virtual String ParamString()
		{
			return "";
		}

		/// <summary>
		/// Consumes this event, if this event can be consumed. Only low-level,
		/// system events can be consumed
		/// </summary>
		protected internal virtual void Consume()
		{
			switch (Id)
			{
			  case KeyEvent.KEY_PRESSED:
			  case KeyEvent.KEY_RELEASED:
			  case MouseEvent.MOUSE_PRESSED:
			  case MouseEvent.MOUSE_RELEASED:
			  case MouseEvent.MOUSE_MOVED:
			  case MouseEvent.MOUSE_DRAGGED:
			  case MouseEvent.MOUSE_ENTERED:
			  case MouseEvent.MOUSE_EXITED:
			  case MouseEvent.MOUSE_WHEEL:
			  case InputMethodEvent.INPUT_METHOD_TEXT_CHANGED:
			  case InputMethodEvent.CARET_POSITION_CHANGED:
				  Consumed_Renamed = true;
				  break;
			  default:
				  // event type cannot be consumed
		  break;
			}
		}

		/// <summary>
		/// Returns whether this event has been consumed.
		/// </summary>
		protected internal virtual bool Consumed
		{
			get
			{
				return Consumed_Renamed;
			}
		}

		/// <summary>
		/// Converts a new event to an old one (used for compatibility).
		/// If the new event cannot be converted (because no old equivalent
		/// exists) then this returns null.
		/// 
		/// Note: this method is here instead of in each individual new
		/// event class in java.awt.event because we don't want to make
		/// it public and it needs to be called from java.awt.
		/// </summary>
		internal virtual Event ConvertToOld()
		{
			Object src = Source;
			int newid = Id;

			switch (Id)
			{
			  case KeyEvent.KEY_PRESSED:
			  case KeyEvent.KEY_RELEASED:
				  KeyEvent ke = (KeyEvent)this;
				  if (ke.ActionKey)
				  {
					  newid = (Id == KeyEvent.KEY_PRESSED? Event.KEY_ACTION : Event.KEY_ACTION_RELEASE);
				  }
				  int keyCode = ke.KeyCode;
				  if (keyCode == KeyEvent.VK_SHIFT || keyCode == KeyEvent.VK_CONTROL || keyCode == KeyEvent.VK_ALT)
				  {
					  return null; // suppress modifier keys in old event model.
				  }
				  // no mask for button1 existed in old Event - strip it out
				  return new Event(src, ke.When, newid, 0, 0, Event.GetOldEventKey(ke), (ke.Modifiers & ~InputEvent.BUTTON1_MASK));

			  case MouseEvent.MOUSE_PRESSED:
			  case MouseEvent.MOUSE_RELEASED:
			  case MouseEvent.MOUSE_MOVED:
			  case MouseEvent.MOUSE_DRAGGED:
			  case MouseEvent.MOUSE_ENTERED:
			  case MouseEvent.MOUSE_EXITED:
				  MouseEvent me = (MouseEvent)this;
				  // no mask for button1 existed in old Event - strip it out
				  Event olde = new Event(src, me.When, newid, me.X, me.Y, 0, (me.Modifiers & ~InputEvent.BUTTON1_MASK));
				  olde.ClickCount = me.ClickCount;
				  return olde;

			  case FocusEvent.FOCUS_GAINED:
				  return new Event(src, Event.GOT_FOCUS, null);

			  case FocusEvent.FOCUS_LOST:
				  return new Event(src, Event.LOST_FOCUS, null);

			  case WindowEvent.WINDOW_CLOSING:
			  case WindowEvent.WINDOW_ICONIFIED:
			  case WindowEvent.WINDOW_DEICONIFIED:
				  return new Event(src, newid, null);

			  case ComponentEvent.COMPONENT_MOVED:
				  if (src is Frame || src is Dialog)
				  {
					  Point p = ((Component)src).Location;
					  return new Event(src, 0, Event.WINDOW_MOVED, p.x, p.y, 0, 0);
				  }
				  break;

			  case ActionEvent.ACTION_PERFORMED:
				  ActionEvent ae = (ActionEvent)this;
				  String cmd;
				  if (src is Button)
				  {
					  cmd = ((Button)src).Label;
				  }
				  else if (src is MenuItem)
				  {
					  cmd = ((MenuItem)src).Label;
				  }
				  else
				  {
					  cmd = ae.ActionCommand;
				  }
				  return new Event(src, 0, newid, 0, 0, 0, ae.Modifiers, cmd);

			  case ItemEvent.ITEM_STATE_CHANGED:
				  ItemEvent ie = (ItemEvent)this;
				  Object arg;
				  if (src is List)
				  {
					  newid = (ie.StateChange == ItemEvent.SELECTED? Event.LIST_SELECT : Event.LIST_DESELECT);
					  arg = ie.Item;
				  }
				  else
				  {
					  newid = Event.ACTION_EVENT;
					  if (src is Choice)
					  {
						  arg = ie.Item;

					  } // Checkbox
					  else
					  {
						  arg = Convert.ToBoolean(ie.StateChange == ItemEvent.SELECTED);
					  }
				  }
				  return new Event(src, newid, arg);

			  case AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED:
				  AdjustmentEvent aje = (AdjustmentEvent)this;
				  switch (aje.AdjustmentType)
				  {
					case AdjustmentEvent.UNIT_INCREMENT:
					  newid = Event.SCROLL_LINE_DOWN;
					  break;
					case AdjustmentEvent.UNIT_DECREMENT:
					  newid = Event.SCROLL_LINE_UP;
					  break;
					case AdjustmentEvent.BLOCK_INCREMENT:
					  newid = Event.SCROLL_PAGE_DOWN;
					  break;
					case AdjustmentEvent.BLOCK_DECREMENT:
					  newid = Event.SCROLL_PAGE_UP;
					  break;
					case AdjustmentEvent.TRACK:
					  if (aje.ValueIsAdjusting)
					  {
						  newid = Event.SCROLL_ABSOLUTE;
					  }
					  else
					  {
						  newid = Event.SCROLL_END;
					  }
					  break;
					default:
					  return null;
				  }
				  return new Event(src, newid, Convert.ToInt32(aje.Value));

			  default:
		  break;
			}
			return null;
		}

		/// <summary>
		/// Copies all private data from this event into that.
		/// Space is allocated for the copied data that will be
		/// freed when the that is finalized. Upon completion,
		/// this event is not changed.
		/// </summary>
		internal virtual void CopyPrivateDataInto(AWTEvent that)
		{
			that.Bdata = this.Bdata;
			// Copy canAccessSystemClipboard value from this into that.
			if (this is InputEvent && that is InputEvent)
			{
				Field field = Get_InputEvent_CanAccessSystemClipboard();
				if (field != null)
				{
					try
					{
						bool b = field.getBoolean(this);
						field.setBoolean(that, b);
					}
					catch (IllegalAccessException e)
					{
						if (Log.isLoggable(PlatformLogger.Level.FINE))
						{
							Log.fine("AWTEvent.copyPrivateDataInto() got IllegalAccessException ", e);
						}
					}
				}
			}
			that.IsSystemGenerated = this.IsSystemGenerated;
		}

		internal virtual void Dispatched()
		{
			if (this is InputEvent)
			{
				Field field = Get_InputEvent_CanAccessSystemClipboard();
				if (field != null)
				{
					try
					{
						field.setBoolean(this, false);
					}
					catch (IllegalAccessException e)
					{
						if (Log.isLoggable(PlatformLogger.Level.FINE))
						{
							Log.fine("AWTEvent.dispatched() got IllegalAccessException ", e);
						}
					}
				}
			}
		}
	} // class AWTEvent

}