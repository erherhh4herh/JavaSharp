using System;

/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

namespace java.awt.@event
{

	using AWTAccessor = sun.awt.AWTAccessor;
	using AppContext = sun.awt.AppContext;
	using SunToolkit = sun.awt.SunToolkit;


	/// <summary>
	/// Input method events contain information about text that is being
	/// composed using an input method. Whenever the text changes, the
	/// input method sends an event. If the text component that's currently
	/// using the input method is an active client, the event is dispatched
	/// to that component. Otherwise, it is dispatched to a separate
	/// composition window.
	/// 
	/// <para>
	/// The text included with the input method event consists of two parts:
	/// committed text and composed text. Either part may be empty. The two
	/// parts together replace any uncommitted composed text sent in previous events,
	/// or the currently selected committed text.
	/// Committed text should be integrated into the text component's persistent
	/// data, it will not be sent again. Composed text may be sent repeatedly,
	/// with changes to reflect the user's editing operations. Committed text
	/// always precedes composed text.
	/// 
	/// @author JavaSoft Asia/Pacific
	/// @since 1.2
	/// </para>
	/// </summary>
	public class InputMethodEvent : AWTEvent
	{

		/// <summary>
		/// Serial Version ID.
		/// </summary>
		private const long SerialVersionUID = 4727190874778922661L;

		/// <summary>
		/// Marks the first integer id for the range of input method event ids.
		/// </summary>
//JAVA TO C# CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
//ORIGINAL LINE: @Native public static final int INPUT_METHOD_FIRST = 1100;
		public const int INPUT_METHOD_FIRST = 1100;

		/// <summary>
		/// The event type indicating changed input method text. This event is
		/// generated by input methods while processing input.
		/// </summary>
//JAVA TO C# CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
//ORIGINAL LINE: @Native public static final int INPUT_METHOD_TEXT_CHANGED = INPUT_METHOD_FIRST;
		public const int INPUT_METHOD_TEXT_CHANGED = INPUT_METHOD_FIRST;

		/// <summary>
		/// The event type indicating a changed insertion point in input method text.
		/// This event is
		/// generated by input methods while processing input if only the caret changed.
		/// </summary>
//JAVA TO C# CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
//ORIGINAL LINE: @Native public static final int CARET_POSITION_CHANGED = INPUT_METHOD_FIRST + 1;
		public static readonly int CARET_POSITION_CHANGED = INPUT_METHOD_FIRST + 1;

		/// <summary>
		/// Marks the last integer id for the range of input method event ids.
		/// </summary>
//JAVA TO C# CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
//ORIGINAL LINE: @Native public static final int INPUT_METHOD_LAST = INPUT_METHOD_FIRST + 1;
		public static readonly int INPUT_METHOD_LAST = INPUT_METHOD_FIRST + 1;

		/// <summary>
		/// The time stamp that indicates when the event was created.
		/// 
		/// @serial </summary>
		/// <seealso cref= #getWhen
		/// @since 1.4 </seealso>
		internal long When_Renamed;

		// Text object
		[NonSerialized]
		private AttributedCharacterIterator Text_Renamed;
		[NonSerialized]
		private int CommittedCharacterCount_Renamed;
		[NonSerialized]
		private TextHitInfo Caret_Renamed;
		[NonSerialized]
		private TextHitInfo VisiblePosition_Renamed;

		/// <summary>
		/// Constructs an <code>InputMethodEvent</code> with the specified
		/// source component, type, time, text, caret, and visiblePosition.
		/// <para>
		/// The offsets of caret and visiblePosition are relative to the current
		/// composed text; that is, the composed text within <code>text</code>
		/// if this is an <code>INPUT_METHOD_TEXT_CHANGED</code> event,
		/// the composed text within the <code>text</code> of the
		/// preceding <code>INPUT_METHOD_TEXT_CHANGED</code> event otherwise.
		/// </para>
		/// <para>Note that passing in an invalid <code>id</code> results in
		/// unspecified behavior. This method throws an
		/// <code>IllegalArgumentException</code> if <code>source</code>
		/// is <code>null</code>.
		/// 
		/// </para>
		/// </summary>
		/// <param name="source"> the object where the event originated </param>
		/// <param name="id"> the event type </param>
		/// <param name="when"> a long integer that specifies the time the event occurred </param>
		/// <param name="text"> the combined committed and composed text,
		///      committed text first; must be <code>null</code>
		///      when the event type is <code>CARET_POSITION_CHANGED</code>;
		///      may be <code>null</code> for
		///      <code>INPUT_METHOD_TEXT_CHANGED</code> if there's no
		///      committed or composed text </param>
		/// <param name="committedCharacterCount"> the number of committed
		///      characters in the text </param>
		/// <param name="caret"> the caret (a.k.a. insertion point);
		///      <code>null</code> if there's no caret within current
		///      composed text </param>
		/// <param name="visiblePosition"> the position that's most important
		///      to be visible; <code>null</code> if there's no
		///      recommendation for a visible position within current
		///      composed text </param>
		/// <exception cref="IllegalArgumentException"> if <code>id</code> is not
		///      in the range
		///      <code>INPUT_METHOD_FIRST</code>..<code>INPUT_METHOD_LAST</code>;
		///      or if id is <code>CARET_POSITION_CHANGED</code> and
		///      <code>text</code> is not <code>null</code>;
		///      or if <code>committedCharacterCount</code> is not in the range
		///      <code>0</code>..<code>(text.getEndIndex() - text.getBeginIndex())</code> </exception>
		/// <exception cref="IllegalArgumentException"> if <code>source</code> is null
		/// 
		/// @since 1.4 </exception>
		public InputMethodEvent(Component source, int id, long when, AttributedCharacterIterator text, int committedCharacterCount, TextHitInfo caret, TextHitInfo visiblePosition) : base(source, id)
		{
			if (id < INPUT_METHOD_FIRST || id > INPUT_METHOD_LAST)
			{
				throw new IllegalArgumentException("id outside of valid range");
			}

			if (id == CARET_POSITION_CHANGED && text != null)
			{
				throw new IllegalArgumentException("text must be null for CARET_POSITION_CHANGED");
			}

			this.When_Renamed = when;
			this.Text_Renamed = text;
			int textLength = 0;
			if (text != null)
			{
				textLength = text.EndIndex - text.BeginIndex;
			}

			if (committedCharacterCount < 0 || committedCharacterCount > textLength)
			{
				throw new IllegalArgumentException("committedCharacterCount outside of valid range");
			}
			this.CommittedCharacterCount_Renamed = committedCharacterCount;

			this.Caret_Renamed = caret;
			this.VisiblePosition_Renamed = visiblePosition;
		}

		/// <summary>
		/// Constructs an <code>InputMethodEvent</code> with the specified
		/// source component, type, text, caret, and visiblePosition.
		/// <para>
		/// The offsets of caret and visiblePosition are relative to the current
		/// composed text; that is, the composed text within <code>text</code>
		/// if this is an <code>INPUT_METHOD_TEXT_CHANGED</code> event,
		/// the composed text within the <code>text</code> of the
		/// preceding <code>INPUT_METHOD_TEXT_CHANGED</code> event otherwise.
		/// The time stamp for this event is initialized by invoking
		/// <seealso cref="java.awt.EventQueue#getMostRecentEventTime()"/>.
		/// </para>
		/// <para>Note that passing in an invalid <code>id</code> results in
		/// unspecified behavior. This method throws an
		/// <code>IllegalArgumentException</code> if <code>source</code>
		/// is <code>null</code>.
		/// 
		/// </para>
		/// </summary>
		/// <param name="source"> the object where the event originated </param>
		/// <param name="id"> the event type </param>
		/// <param name="text"> the combined committed and composed text,
		///      committed text first; must be <code>null</code>
		///      when the event type is <code>CARET_POSITION_CHANGED</code>;
		///      may be <code>null</code> for
		///      <code>INPUT_METHOD_TEXT_CHANGED</code> if there's no
		///      committed or composed text </param>
		/// <param name="committedCharacterCount"> the number of committed
		///      characters in the text </param>
		/// <param name="caret"> the caret (a.k.a. insertion point);
		///      <code>null</code> if there's no caret within current
		///      composed text </param>
		/// <param name="visiblePosition"> the position that's most important
		///      to be visible; <code>null</code> if there's no
		///      recommendation for a visible position within current
		///      composed text </param>
		/// <exception cref="IllegalArgumentException"> if <code>id</code> is not
		///      in the range
		///      <code>INPUT_METHOD_FIRST</code>..<code>INPUT_METHOD_LAST</code>;
		///      or if id is <code>CARET_POSITION_CHANGED</code> and
		///      <code>text</code> is not <code>null</code>;
		///      or if <code>committedCharacterCount</code> is not in the range
		///      <code>0</code>..<code>(text.getEndIndex() - text.getBeginIndex())</code> </exception>
		/// <exception cref="IllegalArgumentException"> if <code>source</code> is null </exception>
		public InputMethodEvent(Component source, int id, AttributedCharacterIterator text, int committedCharacterCount, TextHitInfo caret, TextHitInfo visiblePosition) : this(source, id, GetMostRecentEventTimeForSource(source), text, committedCharacterCount, caret, visiblePosition)
		{
		}

		/// <summary>
		/// Constructs an <code>InputMethodEvent</code> with the
		/// specified source component, type, caret, and visiblePosition.
		/// The text is set to <code>null</code>,
		/// <code>committedCharacterCount</code> to 0.
		/// <para>
		/// The offsets of <code>caret</code> and <code>visiblePosition</code>
		/// are relative to the current composed text; that is,
		/// the composed text within the <code>text</code> of the
		/// preceding <code>INPUT_METHOD_TEXT_CHANGED</code> event if the
		/// event being constructed as a <code>CARET_POSITION_CHANGED</code> event.
		/// For an <code>INPUT_METHOD_TEXT_CHANGED</code> event without text,
		/// <code>caret</code> and <code>visiblePosition</code> must be
		/// <code>null</code>.
		/// The time stamp for this event is initialized by invoking
		/// <seealso cref="java.awt.EventQueue#getMostRecentEventTime()"/>.
		/// </para>
		/// <para>Note that passing in an invalid <code>id</code> results in
		/// unspecified behavior. This method throws an
		/// <code>IllegalArgumentException</code> if <code>source</code>
		/// is <code>null</code>.
		/// 
		/// </para>
		/// </summary>
		/// <param name="source"> the object where the event originated </param>
		/// <param name="id"> the event type </param>
		/// <param name="caret"> the caret (a.k.a. insertion point);
		///      <code>null</code> if there's no caret within current
		///      composed text </param>
		/// <param name="visiblePosition"> the position that's most important
		///      to be visible; <code>null</code> if there's no
		///      recommendation for a visible position within current
		///      composed text </param>
		/// <exception cref="IllegalArgumentException"> if <code>id</code> is not
		///      in the range
		///      <code>INPUT_METHOD_FIRST</code>..<code>INPUT_METHOD_LAST</code> </exception>
		/// <exception cref="IllegalArgumentException"> if <code>source</code> is null </exception>
		public InputMethodEvent(Component source, int id, TextHitInfo caret, TextHitInfo visiblePosition) : this(source, id, GetMostRecentEventTimeForSource(source), null, 0, caret, visiblePosition)
		{
		}

		/// <summary>
		/// Gets the combined committed and composed text.
		/// Characters from index 0 to index <code>getCommittedCharacterCount() - 1</code> are committed
		/// text, the remaining characters are composed text.
		/// </summary>
		/// <returns> the text.
		/// Always null for CARET_POSITION_CHANGED;
		/// may be null for INPUT_METHOD_TEXT_CHANGED if there's no composed or committed text. </returns>
		public virtual AttributedCharacterIterator Text
		{
			get
			{
				return Text_Renamed;
			}
		}

		/// <summary>
		/// Gets the number of committed characters in the text.
		/// </summary>
		public virtual int CommittedCharacterCount
		{
			get
			{
				return CommittedCharacterCount_Renamed;
			}
		}

		/// <summary>
		/// Gets the caret.
		/// <para>
		/// The offset of the caret is relative to the current
		/// composed text; that is, the composed text within getText()
		/// if this is an <code>INPUT_METHOD_TEXT_CHANGED</code> event,
		/// the composed text within getText() of the
		/// preceding <code>INPUT_METHOD_TEXT_CHANGED</code> event otherwise.
		/// 
		/// </para>
		/// </summary>
		/// <returns> the caret (a.k.a. insertion point).
		/// Null if there's no caret within current composed text. </returns>
		public virtual TextHitInfo Caret
		{
			get
			{
				return Caret_Renamed;
			}
		}

		/// <summary>
		/// Gets the position that's most important to be visible.
		/// <para>
		/// The offset of the visible position is relative to the current
		/// composed text; that is, the composed text within getText()
		/// if this is an <code>INPUT_METHOD_TEXT_CHANGED</code> event,
		/// the composed text within getText() of the
		/// preceding <code>INPUT_METHOD_TEXT_CHANGED</code> event otherwise.
		/// 
		/// </para>
		/// </summary>
		/// <returns> the position that's most important to be visible.
		/// Null if there's no recommendation for a visible position within current composed text. </returns>
		public virtual TextHitInfo VisiblePosition
		{
			get
			{
				return VisiblePosition_Renamed;
			}
		}

		/// <summary>
		/// Consumes this event so that it will not be processed
		/// in the default manner by the source which originated it.
		/// </summary>
		public override void Consume()
		{
			Consumed_Renamed = true;
		}

		/// <summary>
		/// Returns whether or not this event has been consumed. </summary>
		/// <seealso cref= #consume </seealso>
		public override bool Consumed
		{
			get
			{
				return Consumed_Renamed;
			}
		}

		/// <summary>
		/// Returns the time stamp of when this event occurred.
		/// </summary>
		/// <returns> this event's timestamp
		/// @since 1.4 </returns>
		public virtual long When
		{
			get
			{
			  return When_Renamed;
			}
		}

		/// <summary>
		/// Returns a parameter string identifying this event.
		/// This method is useful for event-logging and for debugging.
		/// It contains the event ID in text form, the characters of the
		/// committed and composed text
		/// separated by "+", the number of committed characters,
		/// the caret, and the visible position.
		/// </summary>
		/// <returns> a string identifying the event and its attributes </returns>
		public override String ParamString()
		{
			String typeStr;
			switch (Id)
			{
			  case INPUT_METHOD_TEXT_CHANGED:
				  typeStr = "INPUT_METHOD_TEXT_CHANGED";
				  break;
			  case CARET_POSITION_CHANGED:
				  typeStr = "CARET_POSITION_CHANGED";
				  break;
			  default:
				  typeStr = "unknown type";
			  break;
			}

			String textString;
			if (Text_Renamed == null)
			{
				textString = "no text";
			}
			else
			{
				StringBuilder textBuffer = new StringBuilder("\"");
				int committedCharacterCount = this.CommittedCharacterCount_Renamed;
				char c = Text_Renamed.First();
				while (committedCharacterCount-- > 0)
				{
					textBuffer.Append(c);
					c = Text_Renamed.Next();
				}
				textBuffer.Append("\" + \"");
				while (c != java.text.CharacterIterator_Fields.DONE)
				{
					textBuffer.Append(c);
					c = Text_Renamed.Next();
				}
				textBuffer.Append("\"");
				textString = textBuffer.ToString();
			}

			String countString = CommittedCharacterCount_Renamed + " characters committed";

			String caretString;
			if (Caret_Renamed == null)
			{
				caretString = "no caret";
			}
			else
			{
				caretString = "caret: " + Caret_Renamed.ToString();
			}

			String visiblePositionString;
			if (VisiblePosition_Renamed == null)
			{
				visiblePositionString = "no visible position";
			}
			else
			{
				visiblePositionString = "visible position: " + VisiblePosition_Renamed.ToString();
			}

			return typeStr + ", " + textString + ", " + countString + ", " + caretString + ", " + visiblePositionString;
		}

		/// <summary>
		/// Initializes the <code>when</code> field if it is not present in the
		/// object input stream. In that case, the field will be initialized by
		/// invoking <seealso cref="java.awt.EventQueue#getMostRecentEventTime()"/>.
		/// </summary>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: private void readObject(java.io.ObjectInputStream s) throws ClassNotFoundException, java.io.IOException
		private void ReadObject(ObjectInputStream s)
		{
			s.DefaultReadObject();
			if (When_Renamed == 0)
			{
				// Can't use getMostRecentEventTimeForSource because source is always null during deserialization
				When_Renamed = EventQueue.MostRecentEventTime;
			}
		}

		/// <summary>
		/// Get the most recent event time in the {@code EventQueue} which the {@code source}
		/// belongs to.
		/// </summary>
		/// <param name="source"> the source of the event </param>
		/// <exception cref="IllegalArgumentException">  if source is null. </exception>
		/// <returns> most recent event time in the {@code EventQueue} </returns>
		private static long GetMostRecentEventTimeForSource(Object source)
		{
			if (source == null)
			{
				// throw the IllegalArgumentException to conform to EventObject spec
				throw new IllegalArgumentException("null source");
			}
			AppContext appContext = SunToolkit.targetToAppContext(source);
			EventQueue eventQueue = SunToolkit.getSystemEventQueueImplPP(appContext);
			return AWTAccessor.EventQueueAccessor.getMostRecentEventTime(eventQueue);
		}
	}

}