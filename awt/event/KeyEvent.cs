using System;
using System.Runtime.InteropServices;

/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

namespace java.awt.@event
{

	using AWTAccessor = sun.awt.AWTAccessor;

	/// <summary>
	/// An event which indicates that a keystroke occurred in a component.
	/// <para>
	/// This low-level event is generated by a component object (such as a text
	/// field) when a key is pressed, released, or typed.
	/// The event is passed to every <code>KeyListener</code>
	/// or <code>KeyAdapter</code> object which registered to receive such
	/// events using the component's <code>addKeyListener</code> method.
	/// (<code>KeyAdapter</code> objects implement the
	/// <code>KeyListener</code> interface.)  Each such listener object
	/// gets this <code>KeyEvent</code> when the event occurs.
	/// </para>
	/// <para>
	/// <em>"Key typed" events</em> are higher-level and generally do not depend on
	/// the platform or keyboard layout.  They are generated when a Unicode character
	/// is entered, and are the preferred way to find out about character input.
	/// In the simplest case, a key typed event is produced by a single key press
	/// (e.g., 'a').  Often, however, characters are produced by series of key
	/// presses (e.g., 'shift' + 'a'), and the mapping from key pressed events to
	/// key typed events may be many-to-one or many-to-many.  Key releases are not
	/// usually necessary to generate a key typed event, but there are some cases
	/// where the key typed event is not generated until a key is released (e.g.,
	/// entering ASCII sequences via the Alt-Numpad method in Windows).
	/// No key typed events are generated for keys that don't generate Unicode
	/// characters (e.g., action keys, modifier keys, etc.).
	/// </para>
	/// <para>
	/// The getKeyChar method always returns a valid Unicode character or
	/// CHAR_UNDEFINED.  Character input is reported by KEY_TYPED events:
	/// KEY_PRESSED and KEY_RELEASED events are not necessarily associated
	/// with character input.  Therefore, the result of the getKeyChar method
	/// is guaranteed to be meaningful only for KEY_TYPED events.
	/// </para>
	/// <para>
	/// For key pressed and key released events, the getKeyCode method returns
	/// the event's keyCode.  For key typed events, the getKeyCode method
	/// always returns {@code VK_UNDEFINED}. The {@code getExtendedKeyCode} method
	/// may also be used with many international keyboard layouts.
	/// 
	/// </para>
	/// <para>
	/// <em>"Key pressed" and "key released" events</em> are lower-level and depend
	/// on the platform and keyboard layout. They are generated whenever a key is
	/// pressed or released, and are the only way to find out about keys that don't
	/// generate character input (e.g., action keys, modifier keys, etc.). The key
	/// being pressed or released is indicated by the {@code getKeyCode} and {@code getExtendedKeyCode}
	/// methods, which return a virtual key code.
	/// 
	/// </para>
	/// <para>
	/// <em>Virtual key codes</em> are used to report which keyboard key has
	/// been pressed, rather than a character generated by the combination
	/// of one or more keystrokes (such as "A", which comes from shift and "a").
	/// 
	/// </para>
	/// <para>
	/// For example, pressing the Shift key will cause a KEY_PRESSED event
	/// with a VK_SHIFT keyCode, while pressing the 'a' key will result in
	/// a VK_A keyCode.  After the 'a' key is released, a KEY_RELEASED event
	/// will be fired with VK_A. Separately, a KEY_TYPED event with a keyChar
	/// value of 'A' is generated.
	/// 
	/// </para>
	/// <para>
	/// Pressing and releasing a key on the keyboard results in the generating
	/// the following key events (in order):
	/// <PRE>
	///    {@code KEY_PRESSED}
	///    {@code KEY_TYPED} (is only generated if a valid Unicode character could be generated.)
	///    {@code KEY_RELEASED}
	/// </PRE>
	/// 
	/// But in some cases (e.g. auto-repeat or input method is activated) the order
	/// could be different (and platform dependent).
	/// 
	/// </para>
	/// <para>
	/// Notes:
	/// <ul>
	/// <li>Key combinations which do not result in Unicode characters, such as action
	/// keys like F1 and the HELP key, do not generate KEY_TYPED events.
	/// <li>Not all keyboards or systems are capable of generating all
	/// virtual key codes.  No attempt is made in Java to generate these keys
	/// artificially.
	/// <li>Virtual key codes do not identify a physical key: they depend on the
	/// platform and keyboard layout. For example, the key that generates VK_Q
	/// when using a U.S. keyboard layout will generate VK_A when using a French
	/// keyboard layout.
	/// <li>The key that generates {@code VK_Q} when using a U.S. keyboard layout also
	/// generates a unique code for Russian or Hebrew layout. There is no a
	/// {@code VK_} constant for these and many other codes in various layouts. These codes
	/// may be obtained by using {@code getExtendedKeyCode} and are used whenever
	/// a {@code VK_} constant is used.
	/// <li>Not all characters have a keycode associated with them.  For example,
	/// there is no keycode for the question mark because there is no keyboard
	/// for which it appears on the primary layer.
	/// <li>In order to support the platform-independent handling of action keys,
	/// the Java platform uses a few additional virtual key constants for functions
	/// that would otherwise have to be recognized by interpreting virtual key codes
	/// and modifiers. For example, for Japanese Windows keyboards, VK_ALL_CANDIDATES
	/// is returned instead of VK_CONVERT with the ALT modifier.
	/// <li>As specified in <a href="../doc-files/FocusSpec.html">Focus Specification</a>
	/// key events are dispatched to the focus owner by default.
	/// </ul>
	/// 
	/// </para>
	/// <para>
	/// WARNING: Aside from those keys that are defined by the Java language
	/// (VK_ENTER, VK_BACK_SPACE, and VK_TAB), do not rely on the values of the VK_
	/// constants.  Sun reserves the right to change these values as needed
	/// to accommodate a wider range of keyboards in the future.
	/// </para>
	/// <para>
	/// An unspecified behavior will be caused if the {@code id} parameter
	/// of any particular {@code KeyEvent} instance is not
	/// in the range from {@code KEY_FIRST} to {@code KEY_LAST}.
	/// 
	/// @author Carl Quinn
	/// @author Amy Fowler
	/// @author Norbert Lindenberg
	/// 
	/// </para>
	/// </summary>
	/// <seealso cref= KeyAdapter </seealso>
	/// <seealso cref= KeyListener </seealso>
	/// <seealso cref= <a href="https://docs.oracle.com/javase/tutorial/uiswing/events/keylistener.html">Tutorial: Writing a Key Listener</a>
	/// 
	/// @since 1.1 </seealso>
	public class KeyEvent : InputEvent
	{

		/// <summary>
		/// Stores the state of native event dispatching system
		/// - true, if when the event was created event proxying
		///         mechanism was active
		/// - false, if it was inactive
		/// Used in Component.dispatchEventImpl to correctly dispatch
		/// events when proxy is active
		/// </summary>
		private bool IsProxyActive = false;

		/// <summary>
		/// The first number in the range of ids used for key events.
		/// </summary>
		public const int KEY_FIRST = 400;

		/// <summary>
		/// The last number in the range of ids used for key events.
		/// </summary>
		public const int KEY_LAST = 402;

		/// <summary>
		/// The "key typed" event.  This event is generated when a character is
		/// entered.  In the simplest case, it is produced by a single key press.
		/// Often, however, characters are produced by series of key presses, and
		/// the mapping from key pressed events to key typed events may be
		/// many-to-one or many-to-many.
		/// </summary>
		public const int KEY_TYPED = KEY_FIRST;

		/// <summary>
		/// The "key pressed" event. This event is generated when a key
		/// is pushed down.
		/// </summary>
		public static readonly int KEY_PRESSED = 1 + KEY_FIRST; //Event.KEY_PRESS

		/// <summary>
		/// The "key released" event. This event is generated when a key
		/// is let up.
		/// </summary>
		public static readonly int KEY_RELEASED = 2 + KEY_FIRST; //Event.KEY_RELEASE

		/* Virtual key codes. */

		public const int VK_ENTER = '\n';
		public const int VK_BACK_SPACE = '\b';
		public const int VK_TAB = '\t';
		public const int VK_CANCEL = 0x03;
		public const int VK_CLEAR = 0x0C;
		public const int VK_SHIFT = 0x10;
		public const int VK_CONTROL = 0x11;
		public const int VK_ALT = 0x12;
		public const int VK_PAUSE = 0x13;
		public const int VK_CAPS_LOCK = 0x14;
		public const int VK_ESCAPE = 0x1B;
		public const int VK_SPACE = 0x20;
		public const int VK_PAGE_UP = 0x21;
		public const int VK_PAGE_DOWN = 0x22;
		public const int VK_END = 0x23;
		public const int VK_HOME = 0x24;

		/// <summary>
		/// Constant for the non-numpad <b>left</b> arrow key. </summary>
		/// <seealso cref= #VK_KP_LEFT </seealso>
		public const int VK_LEFT = 0x25;

		/// <summary>
		/// Constant for the non-numpad <b>up</b> arrow key. </summary>
		/// <seealso cref= #VK_KP_UP </seealso>
		public const int VK_UP = 0x26;

		/// <summary>
		/// Constant for the non-numpad <b>right</b> arrow key. </summary>
		/// <seealso cref= #VK_KP_RIGHT </seealso>
		public const int VK_RIGHT = 0x27;

		/// <summary>
		/// Constant for the non-numpad <b>down</b> arrow key. </summary>
		/// <seealso cref= #VK_KP_DOWN </seealso>
		public const int VK_DOWN = 0x28;

		/// <summary>
		/// Constant for the comma key, ","
		/// </summary>
		public const int VK_COMMA = 0x2C;

		/// <summary>
		/// Constant for the minus key, "-"
		/// @since 1.2
		/// </summary>
		public const int VK_MINUS = 0x2D;

		/// <summary>
		/// Constant for the period key, "."
		/// </summary>
		public const int VK_PERIOD = 0x2E;

		/// <summary>
		/// Constant for the forward slash key, "/"
		/// </summary>
		public const int VK_SLASH = 0x2F;

		/// <summary>
		/// VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39) </summary>
		public const int VK_0 = 0x30;
		public const int VK_1 = 0x31;
		public const int VK_2 = 0x32;
		public const int VK_3 = 0x33;
		public const int VK_4 = 0x34;
		public const int VK_5 = 0x35;
		public const int VK_6 = 0x36;
		public const int VK_7 = 0x37;
		public const int VK_8 = 0x38;
		public const int VK_9 = 0x39;

		/// <summary>
		/// Constant for the semicolon key, ";"
		/// </summary>
		public const int VK_SEMICOLON = 0x3B;

		/// <summary>
		/// Constant for the equals key, "="
		/// </summary>
		public const int VK_EQUALS = 0x3D;

		/// <summary>
		/// VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) </summary>
		public const int VK_A = 0x41;
		public const int VK_B = 0x42;
		public const int VK_C = 0x43;
		public const int VK_D = 0x44;
		public const int VK_E = 0x45;
		public const int VK_F = 0x46;
		public const int VK_G = 0x47;
		public const int VK_H = 0x48;
		public const int VK_I = 0x49;
		public const int VK_J = 0x4A;
		public const int VK_K = 0x4B;
		public const int VK_L = 0x4C;
		public const int VK_M = 0x4D;
		public const int VK_N = 0x4E;
		public const int VK_O = 0x4F;
		public const int VK_P = 0x50;
		public const int VK_Q = 0x51;
		public const int VK_R = 0x52;
		public const int VK_S = 0x53;
		public const int VK_T = 0x54;
		public const int VK_U = 0x55;
		public const int VK_V = 0x56;
		public const int VK_W = 0x57;
		public const int VK_X = 0x58;
		public const int VK_Y = 0x59;
		public const int VK_Z = 0x5A;

		/// <summary>
		/// Constant for the open bracket key, "["
		/// </summary>
		public const int VK_OPEN_BRACKET = 0x5B;

		/// <summary>
		/// Constant for the back slash key, "\"
		/// </summary>
		public const int VK_BACK_SLASH = 0x5C;

		/// <summary>
		/// Constant for the close bracket key, "]"
		/// </summary>
		public const int VK_CLOSE_BRACKET = 0x5D;

		public const int VK_NUMPAD0 = 0x60;
		public const int VK_NUMPAD1 = 0x61;
		public const int VK_NUMPAD2 = 0x62;
		public const int VK_NUMPAD3 = 0x63;
		public const int VK_NUMPAD4 = 0x64;
		public const int VK_NUMPAD5 = 0x65;
		public const int VK_NUMPAD6 = 0x66;
		public const int VK_NUMPAD7 = 0x67;
		public const int VK_NUMPAD8 = 0x68;
		public const int VK_NUMPAD9 = 0x69;
		public const int VK_MULTIPLY = 0x6A;
		public const int VK_ADD = 0x6B;

		/// <summary>
		/// This constant is obsolete, and is included only for backwards
		/// compatibility. </summary>
		/// <seealso cref= #VK_SEPARATOR </seealso>
		public const int VK_SEPARATER = 0x6C;

		/// <summary>
		/// Constant for the Numpad Separator key.
		/// @since 1.4
		/// </summary>
		public const int VK_SEPARATOR = VK_SEPARATER;

		public const int VK_SUBTRACT = 0x6D;
		public const int VK_DECIMAL = 0x6E;
		public const int VK_DIVIDE = 0x6F;
		public const int VK_DELETE = 0x7F; // ASCII DEL
		public const int VK_NUM_LOCK = 0x90;
		public const int VK_SCROLL_LOCK = 0x91;

		/// <summary>
		/// Constant for the F1 function key. </summary>
		public const int VK_F1 = 0x70;

		/// <summary>
		/// Constant for the F2 function key. </summary>
		public const int VK_F2 = 0x71;

		/// <summary>
		/// Constant for the F3 function key. </summary>
		public const int VK_F3 = 0x72;

		/// <summary>
		/// Constant for the F4 function key. </summary>
		public const int VK_F4 = 0x73;

		/// <summary>
		/// Constant for the F5 function key. </summary>
		public const int VK_F5 = 0x74;

		/// <summary>
		/// Constant for the F6 function key. </summary>
		public const int VK_F6 = 0x75;

		/// <summary>
		/// Constant for the F7 function key. </summary>
		public const int VK_F7 = 0x76;

		/// <summary>
		/// Constant for the F8 function key. </summary>
		public const int VK_F8 = 0x77;

		/// <summary>
		/// Constant for the F9 function key. </summary>
		public const int VK_F9 = 0x78;

		/// <summary>
		/// Constant for the F10 function key. </summary>
		public const int VK_F10 = 0x79;

		/// <summary>
		/// Constant for the F11 function key. </summary>
		public const int VK_F11 = 0x7A;

		/// <summary>
		/// Constant for the F12 function key. </summary>
		public const int VK_F12 = 0x7B;

		/// <summary>
		/// Constant for the F13 function key.
		/// @since 1.2
		/// </summary>
		/* F13 - F24 are used on IBM 3270 keyboard; use random range for constants. */
		public const int VK_F13 = 0xF000;

		/// <summary>
		/// Constant for the F14 function key.
		/// @since 1.2
		/// </summary>
		public const int VK_F14 = 0xF001;

		/// <summary>
		/// Constant for the F15 function key.
		/// @since 1.2
		/// </summary>
		public const int VK_F15 = 0xF002;

		/// <summary>
		/// Constant for the F16 function key.
		/// @since 1.2
		/// </summary>
		public const int VK_F16 = 0xF003;

		/// <summary>
		/// Constant for the F17 function key.
		/// @since 1.2
		/// </summary>
		public const int VK_F17 = 0xF004;

		/// <summary>
		/// Constant for the F18 function key.
		/// @since 1.2
		/// </summary>
		public const int VK_F18 = 0xF005;

		/// <summary>
		/// Constant for the F19 function key.
		/// @since 1.2
		/// </summary>
		public const int VK_F19 = 0xF006;

		/// <summary>
		/// Constant for the F20 function key.
		/// @since 1.2
		/// </summary>
		public const int VK_F20 = 0xF007;

		/// <summary>
		/// Constant for the F21 function key.
		/// @since 1.2
		/// </summary>
		public const int VK_F21 = 0xF008;

		/// <summary>
		/// Constant for the F22 function key.
		/// @since 1.2
		/// </summary>
		public const int VK_F22 = 0xF009;

		/// <summary>
		/// Constant for the F23 function key.
		/// @since 1.2
		/// </summary>
		public const int VK_F23 = 0xF00A;

		/// <summary>
		/// Constant for the F24 function key.
		/// @since 1.2
		/// </summary>
		public const int VK_F24 = 0xF00B;

		public const int VK_PRINTSCREEN = 0x9A;
		public const int VK_INSERT = 0x9B;
		public const int VK_HELP = 0x9C;
		public const int VK_META = 0x9D;

		public const int VK_BACK_QUOTE = 0xC0;
		public const int VK_QUOTE = 0xDE;

		/// <summary>
		/// Constant for the numeric keypad <b>up</b> arrow key. </summary>
		/// <seealso cref= #VK_UP
		/// @since 1.2 </seealso>
		public const int VK_KP_UP = 0xE0;

		/// <summary>
		/// Constant for the numeric keypad <b>down</b> arrow key. </summary>
		/// <seealso cref= #VK_DOWN
		/// @since 1.2 </seealso>
		public const int VK_KP_DOWN = 0xE1;

		/// <summary>
		/// Constant for the numeric keypad <b>left</b> arrow key. </summary>
		/// <seealso cref= #VK_LEFT
		/// @since 1.2 </seealso>
		public const int VK_KP_LEFT = 0xE2;

		/// <summary>
		/// Constant for the numeric keypad <b>right</b> arrow key. </summary>
		/// <seealso cref= #VK_RIGHT
		/// @since 1.2 </seealso>
		public const int VK_KP_RIGHT = 0xE3;

		/* For European keyboards */
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_DEAD_GRAVE = 0x80;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_DEAD_ACUTE = 0x81;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_DEAD_CIRCUMFLEX = 0x82;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_DEAD_TILDE = 0x83;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_DEAD_MACRON = 0x84;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_DEAD_BREVE = 0x85;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_DEAD_ABOVEDOT = 0x86;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_DEAD_DIAERESIS = 0x87;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_DEAD_ABOVERING = 0x88;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_DEAD_DOUBLEACUTE = 0x89;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_DEAD_CARON = 0x8a;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_DEAD_CEDILLA = 0x8b;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_DEAD_OGONEK = 0x8c;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_DEAD_IOTA = 0x8d;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_DEAD_VOICED_SOUND = 0x8e;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_DEAD_SEMIVOICED_SOUND = 0x8f;

		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_AMPERSAND = 0x96;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_ASTERISK = 0x97;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_QUOTEDBL = 0x98;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_LESS = 0x99;

		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_GREATER = 0xa0;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_BRACELEFT = 0xa1;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_BRACERIGHT = 0xa2;

		/// <summary>
		/// Constant for the "@" key.
		/// @since 1.2
		/// </summary>
		public const int VK_AT = 0x0200;

		/// <summary>
		/// Constant for the ":" key.
		/// @since 1.2
		/// </summary>
		public const int VK_COLON = 0x0201;

		/// <summary>
		/// Constant for the "^" key.
		/// @since 1.2
		/// </summary>
		public const int VK_CIRCUMFLEX = 0x0202;

		/// <summary>
		/// Constant for the "$" key.
		/// @since 1.2
		/// </summary>
		public const int VK_DOLLAR = 0x0203;

		/// <summary>
		/// Constant for the Euro currency sign key.
		/// @since 1.2
		/// </summary>
		public const int VK_EURO_SIGN = 0x0204;

		/// <summary>
		/// Constant for the "!" key.
		/// @since 1.2
		/// </summary>
		public const int VK_EXCLAMATION_MARK = 0x0205;

		/// <summary>
		/// Constant for the inverted exclamation mark key.
		/// @since 1.2
		/// </summary>
		public const int VK_INVERTED_EXCLAMATION_MARK = 0x0206;

		/// <summary>
		/// Constant for the "(" key.
		/// @since 1.2
		/// </summary>
		public const int VK_LEFT_PARENTHESIS = 0x0207;

		/// <summary>
		/// Constant for the "#" key.
		/// @since 1.2
		/// </summary>
		public const int VK_NUMBER_SIGN = 0x0208;

		/// <summary>
		/// Constant for the "+" key.
		/// @since 1.2
		/// </summary>
		public const int VK_PLUS = 0x0209;

		/// <summary>
		/// Constant for the ")" key.
		/// @since 1.2
		/// </summary>
		public const int VK_RIGHT_PARENTHESIS = 0x020A;

		/// <summary>
		/// Constant for the "_" key.
		/// @since 1.2
		/// </summary>
		public const int VK_UNDERSCORE = 0x020B;

		/// <summary>
		/// Constant for the Microsoft Windows "Windows" key.
		/// It is used for both the left and right version of the key. </summary>
		/// <seealso cref= #getKeyLocation()
		/// @since 1.5 </seealso>
		public const int VK_WINDOWS = 0x020C;

		/// <summary>
		/// Constant for the Microsoft Windows Context Menu key.
		/// @since 1.5
		/// </summary>
		public const int VK_CONTEXT_MENU = 0x020D;

		/* for input method support on Asian Keyboards */

		/* not clear what this means - listed in Microsoft Windows API */
		public const int VK_FINAL = 0x0018;

		/// <summary>
		/// Constant for the Convert function key. </summary>
		/* Japanese PC 106 keyboard, Japanese Solaris keyboard: henkan */
		public const int VK_CONVERT = 0x001C;

		/// <summary>
		/// Constant for the Don't Convert function key. </summary>
		/* Japanese PC 106 keyboard: muhenkan */
		public const int VK_NONCONVERT = 0x001D;

		/// <summary>
		/// Constant for the Accept or Commit function key. </summary>
		/* Japanese Solaris keyboard: kakutei */
		public const int VK_ACCEPT = 0x001E;

		/* not clear what this means - listed in Microsoft Windows API */
		public const int VK_MODECHANGE = 0x001F;

		/* replaced by VK_KANA_LOCK for Microsoft Windows and Solaris;
		   might still be used on other platforms */
		public const int VK_KANA = 0x0015;

		/* replaced by VK_INPUT_METHOD_ON_OFF for Microsoft Windows and Solaris;
		   might still be used for other platforms */
		public const int VK_KANJI = 0x0019;

		/// <summary>
		/// Constant for the Alphanumeric function key.
		/// @since 1.2
		/// </summary>
		/* Japanese PC 106 keyboard: eisuu */
		public const int VK_ALPHANUMERIC = 0x00F0;

		/// <summary>
		/// Constant for the Katakana function key.
		/// @since 1.2
		/// </summary>
		/* Japanese PC 106 keyboard: katakana */
		public const int VK_KATAKANA = 0x00F1;

		/// <summary>
		/// Constant for the Hiragana function key.
		/// @since 1.2
		/// </summary>
		/* Japanese PC 106 keyboard: hiragana */
		public const int VK_HIRAGANA = 0x00F2;

		/// <summary>
		/// Constant for the Full-Width Characters function key.
		/// @since 1.2
		/// </summary>
		/* Japanese PC 106 keyboard: zenkaku */
		public const int VK_FULL_WIDTH = 0x00F3;

		/// <summary>
		/// Constant for the Half-Width Characters function key.
		/// @since 1.2
		/// </summary>
		/* Japanese PC 106 keyboard: hankaku */
		public const int VK_HALF_WIDTH = 0x00F4;

		/// <summary>
		/// Constant for the Roman Characters function key.
		/// @since 1.2
		/// </summary>
		/* Japanese PC 106 keyboard: roumaji */
		public const int VK_ROMAN_CHARACTERS = 0x00F5;

		/// <summary>
		/// Constant for the All Candidates function key.
		/// @since 1.2
		/// </summary>
		/* Japanese PC 106 keyboard - VK_CONVERT + ALT: zenkouho */
		public const int VK_ALL_CANDIDATES = 0x0100;

		/// <summary>
		/// Constant for the Previous Candidate function key.
		/// @since 1.2
		/// </summary>
		/* Japanese PC 106 keyboard - VK_CONVERT + SHIFT: maekouho */
		public const int VK_PREVIOUS_CANDIDATE = 0x0101;

		/// <summary>
		/// Constant for the Code Input function key.
		/// @since 1.2
		/// </summary>
		/* Japanese PC 106 keyboard - VK_ALPHANUMERIC + ALT: kanji bangou */
		public const int VK_CODE_INPUT = 0x0102;

		/// <summary>
		/// Constant for the Japanese-Katakana function key.
		/// This key switches to a Japanese input method and selects its Katakana input mode.
		/// @since 1.2
		/// </summary>
		/* Japanese Macintosh keyboard - VK_JAPANESE_HIRAGANA + SHIFT */
		public const int VK_JAPANESE_KATAKANA = 0x0103;

		/// <summary>
		/// Constant for the Japanese-Hiragana function key.
		/// This key switches to a Japanese input method and selects its Hiragana input mode.
		/// @since 1.2
		/// </summary>
		/* Japanese Macintosh keyboard */
		public const int VK_JAPANESE_HIRAGANA = 0x0104;

		/// <summary>
		/// Constant for the Japanese-Roman function key.
		/// This key switches to a Japanese input method and selects its Roman-Direct input mode.
		/// @since 1.2
		/// </summary>
		/* Japanese Macintosh keyboard */
		public const int VK_JAPANESE_ROMAN = 0x0105;

		/// <summary>
		/// Constant for the locking Kana function key.
		/// This key locks the keyboard into a Kana layout.
		/// @since 1.3
		/// </summary>
		/* Japanese PC 106 keyboard with special Windows driver - eisuu + Control; Japanese Solaris keyboard: kana */
		public const int VK_KANA_LOCK = 0x0106;

		/// <summary>
		/// Constant for the input method on/off key.
		/// @since 1.3
		/// </summary>
		/* Japanese PC 106 keyboard: kanji. Japanese Solaris keyboard: nihongo */
		public const int VK_INPUT_METHOD_ON_OFF = 0x0107;

		/* for Sun keyboards */
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_CUT = 0xFFD1;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_COPY = 0xFFCD;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_PASTE = 0xFFCF;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_UNDO = 0xFFCB;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_AGAIN = 0xFFC9;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_FIND = 0xFFD0;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_PROPS = 0xFFCA;
		/// <summary>
		/// @since 1.2 </summary>
		public const int VK_STOP = 0xFFC8;

		/// <summary>
		/// Constant for the Compose function key.
		/// @since 1.2
		/// </summary>
		public const int VK_COMPOSE = 0xFF20;

		/// <summary>
		/// Constant for the AltGraph function key.
		/// @since 1.2
		/// </summary>
		public const int VK_ALT_GRAPH = 0xFF7E;

		/// <summary>
		/// Constant for the Begin key.
		/// @since 1.5
		/// </summary>
		public const int VK_BEGIN = 0xFF58;

		/// <summary>
		/// This value is used to indicate that the keyCode is unknown.
		/// KEY_TYPED events do not have a keyCode value; this value
		/// is used instead.
		/// </summary>
		public const int VK_UNDEFINED = 0x0;

		/// <summary>
		/// KEY_PRESSED and KEY_RELEASED events which do not map to a
		/// valid Unicode character use this for the keyChar value.
		/// </summary>
		public const char CHAR_UNDEFINED = (char)0xFFFF;

		/// <summary>
		/// A constant indicating that the keyLocation is indeterminate
		/// or not relevant.
		/// <code>KEY_TYPED</code> events do not have a keyLocation; this value
		/// is used instead.
		/// @since 1.4
		/// </summary>
		public const int KEY_LOCATION_UNKNOWN = 0;

		/// <summary>
		/// A constant indicating that the key pressed or released
		/// is not distinguished as the left or right version of a key,
		/// and did not originate on the numeric keypad (or did not
		/// originate with a virtual key corresponding to the numeric
		/// keypad).
		/// @since 1.4
		/// </summary>
		public const int KEY_LOCATION_STANDARD = 1;

		/// <summary>
		/// A constant indicating that the key pressed or released is in
		/// the left key location (there is more than one possible location
		/// for this key).  Example: the left shift key.
		/// @since 1.4
		/// </summary>
		public const int KEY_LOCATION_LEFT = 2;

		/// <summary>
		/// A constant indicating that the key pressed or released is in
		/// the right key location (there is more than one possible location
		/// for this key).  Example: the right shift key.
		/// @since 1.4
		/// </summary>
		public const int KEY_LOCATION_RIGHT = 3;

		/// <summary>
		/// A constant indicating that the key event originated on the
		/// numeric keypad or with a virtual key corresponding to the
		/// numeric keypad.
		/// @since 1.4
		/// </summary>
		public const int KEY_LOCATION_NUMPAD = 4;

		/// <summary>
		/// The unique value assigned to each of the keys on the
		/// keyboard.  There is a common set of key codes that
		/// can be fired by most keyboards.
		/// The symbolic name for a key code should be used rather
		/// than the code value itself.
		/// 
		/// @serial </summary>
		/// <seealso cref= #getKeyCode() </seealso>
		/// <seealso cref= #setKeyCode(int) </seealso>
		internal int KeyCode_Renamed;

		/// <summary>
		/// <code>keyChar</code> is a valid unicode character
		/// that is fired by a key or a key combination on
		/// a keyboard.
		/// 
		/// @serial </summary>
		/// <seealso cref= #getKeyChar() </seealso>
		/// <seealso cref= #setKeyChar(char) </seealso>
		internal char KeyChar_Renamed;

		/// <summary>
		/// The location of the key on the keyboard.
		/// 
		/// Some keys occur more than once on a keyboard, e.g. the left and
		/// right shift keys.  Additionally, some keys occur on the numeric
		/// keypad.  This variable is used to distinguish such keys.
		/// 
		/// The only legal values are <code>KEY_LOCATION_UNKNOWN</code>,
		/// <code>KEY_LOCATION_STANDARD</code>, <code>KEY_LOCATION_LEFT</code>,
		/// <code>KEY_LOCATION_RIGHT</code>, and <code>KEY_LOCATION_NUMPAD</code>.
		/// 
		/// @serial </summary>
		/// <seealso cref= #getKeyLocation() </seealso>
		internal int KeyLocation_Renamed;

		//set from native code.
		[NonSerialized]
		private long RawCode = 0;
		[NonSerialized]
		private long PrimaryLevelUnicode = 0;
		[NonSerialized]
		private long Scancode = 0; // for MS Windows only
		[NonSerialized]
		private long ExtendedKeyCode_Renamed = 0;

		/*
		 * JDK 1.1 serialVersionUID
		 */
		private new const long SerialVersionUID = -2352130953028126954L;

		static KeyEvent()
		{
			/* ensure that the necessary native libraries are loaded */
			NativeLibLoader.LoadLibraries();
			if (!GraphicsEnvironment.Headless)
			{
				initIDs();
			}

			AWTAccessor.KeyEventAccessor = new KeyEventAccessorAnonymousInnerClassHelper();
		}

		private class KeyEventAccessorAnonymousInnerClassHelper : AWTAccessor.KeyEventAccessor
		{
			public KeyEventAccessorAnonymousInnerClassHelper()
			{
			}

			public virtual void SetRawCode(KeyEvent ev, long rawCode)
			{
				ev.RawCode = rawCode;
			}

			public virtual void SetPrimaryLevelUnicode(KeyEvent ev, long primaryLevelUnicode)
			{
				ev.PrimaryLevelUnicode = primaryLevelUnicode;
			}

			public virtual void SetExtendedKeyCode(KeyEvent ev, long extendedKeyCode)
			{
				ev.ExtendedKeyCode_Renamed = extendedKeyCode;
			}

			public virtual Component GetOriginalSource(KeyEvent ev)
			{
				return ev.OriginalSource;
			}
		}

		/// <summary>
		/// Initialize JNI field and method IDs for fields that may be
		/// accessed from C.
		/// </summary>
//JAVA TO C# CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		[DllImport("unknown")]
		private static extern void initIDs();

		/// <summary>
		/// The original event source.
		/// 
		/// Event source can be changed during processing, but in some cases
		/// we need to be able to obtain original source.
		/// </summary>
		private Component OriginalSource;

		private KeyEvent(Component source, int id, long when, int modifiers, int keyCode, char keyChar, int keyLocation, bool isProxyActive) : this(source, id, when, modifiers, keyCode, keyChar, keyLocation)
		{
			this.IsProxyActive = isProxyActive;
		}

		/// <summary>
		/// Constructs a <code>KeyEvent</code> object.
		/// <para>This method throws an
		/// <code>IllegalArgumentException</code> if <code>source</code>
		/// is <code>null</code>.
		/// 
		/// </para>
		/// </summary>
		/// <param name="source">    The <code>Component</code> that originated the event </param>
		/// <param name="id">              An integer indicating the type of event.
		///                  For information on allowable values, see
		///                  the class description for <seealso cref="KeyEvent"/> </param>
		/// <param name="when">      A long integer that specifies the time the event
		///                  occurred.
		///                     Passing negative or zero value
		///                     is not recommended </param>
		/// <param name="modifiers"> The modifier keys down during event (shift, ctrl,
		///                  alt, meta).
		///                     Passing negative value
		///                     is not recommended.
		///                     Zero value means that no modifiers were passed.
		///                  Use either an extended _DOWN_MASK or old _MASK modifiers,
		///                  however do not mix models in the one event.
		///                  The extended modifiers are preferred for using </param>
		/// <param name="keyCode">   The integer code for an actual key, or VK_UNDEFINED
		///                  (for a key-typed event) </param>
		/// <param name="keyChar">   The Unicode character generated by this event, or
		///                  CHAR_UNDEFINED (for key-pressed and key-released
		///                  events which do not map to a valid Unicode character) </param>
		/// <param name="keyLocation">  Identifies the key location.  The only legal
		///        values are <code>KEY_LOCATION_UNKNOWN</code>,
		///        <code>KEY_LOCATION_STANDARD</code>, <code>KEY_LOCATION_LEFT</code>,
		///        <code>KEY_LOCATION_RIGHT</code>, and <code>KEY_LOCATION_NUMPAD</code>. </param>
		/// <exception cref="IllegalArgumentException">
		///     if <code>id</code> is <code>KEY_TYPED</code> and
		///       <code>keyChar</code> is <code>CHAR_UNDEFINED</code>;
		///     or if <code>id</code> is <code>KEY_TYPED</code> and
		///       <code>keyCode</code> is not <code>VK_UNDEFINED</code>;
		///     or if <code>id</code> is <code>KEY_TYPED</code> and
		///       <code>keyLocation</code> is not <code>KEY_LOCATION_UNKNOWN</code>;
		///     or if <code>keyLocation</code> is not one of the legal
		///       values enumerated above. </exception>
		/// <exception cref="IllegalArgumentException"> if <code>source</code> is null </exception>
		/// <seealso cref= #getSource() </seealso>
		/// <seealso cref= #getID() </seealso>
		/// <seealso cref= #getWhen() </seealso>
		/// <seealso cref= #getModifiers() </seealso>
		/// <seealso cref= #getKeyCode() </seealso>
		/// <seealso cref= #getKeyChar() </seealso>
		/// <seealso cref= #getKeyLocation()
		/// @since 1.4 </seealso>
		public KeyEvent(Component source, int id, long when, int modifiers, int keyCode, char keyChar, int keyLocation) : base(source, id, when, modifiers)
		{
			if (id == KEY_TYPED)
			{
				if (keyChar == CHAR_UNDEFINED)
				{
					throw new IllegalArgumentException("invalid keyChar");
				}
				if (keyCode != VK_UNDEFINED)
				{
					throw new IllegalArgumentException("invalid keyCode");
				}
				if (keyLocation != KEY_LOCATION_UNKNOWN)
				{
					throw new IllegalArgumentException("invalid keyLocation");
				}
			}

			this.KeyCode_Renamed = keyCode;
			this.KeyChar_Renamed = keyChar;

			if ((keyLocation < KEY_LOCATION_UNKNOWN) || (keyLocation > KEY_LOCATION_NUMPAD))
			{
				throw new IllegalArgumentException("invalid keyLocation");
			}
			this.KeyLocation_Renamed = keyLocation;
			if ((Modifiers != 0) && (ModifiersEx == 0))
			{
				SetNewModifiers();
			}
			else if ((Modifiers == 0) && (ModifiersEx != 0))
			{
				SetOldModifiers();
			}
			OriginalSource = source;
		}

		/// <summary>
		/// Constructs a <code>KeyEvent</code> object.
		/// <para> This method throws an
		/// <code>IllegalArgumentException</code> if <code>source</code>
		/// is <code>null</code>.
		/// 
		/// </para>
		/// </summary>
		/// <param name="source">    The <code>Component</code> that originated the event </param>
		/// <param name="id">              An integer indicating the type of event.
		///                  For information on allowable values, see
		///                  the class description for <seealso cref="KeyEvent"/> </param>
		/// <param name="when">      A long integer that specifies the time the event
		///                  occurred.
		///                     Passing negative or zero value
		///                     is not recommended </param>
		/// <param name="modifiers"> The modifier keys down during event (shift, ctrl,
		///                  alt, meta).
		///                     Passing negative value
		///                     is not recommended.
		///                     Zero value means that no modifiers were passed.
		///                  Use either an extended _DOWN_MASK or old _MASK modifiers,
		///                  however do not mix models in the one event.
		///                  The extended modifiers are preferred for using </param>
		/// <param name="keyCode">   The integer code for an actual key, or VK_UNDEFINED
		///                  (for a key-typed event) </param>
		/// <param name="keyChar">   The Unicode character generated by this event, or
		///                  CHAR_UNDEFINED (for key-pressed and key-released
		///                  events which do not map to a valid Unicode character) </param>
		/// <exception cref="IllegalArgumentException">  if <code>id</code> is
		///     <code>KEY_TYPED</code> and <code>keyChar</code> is
		///     <code>CHAR_UNDEFINED</code>; or if <code>id</code> is
		///     <code>KEY_TYPED</code> and <code>keyCode</code> is not
		///     <code>VK_UNDEFINED</code> </exception>
		/// <exception cref="IllegalArgumentException"> if <code>source</code> is null </exception>
		/// <seealso cref= #getSource() </seealso>
		/// <seealso cref= #getID() </seealso>
		/// <seealso cref= #getWhen() </seealso>
		/// <seealso cref= #getModifiers() </seealso>
		/// <seealso cref= #getKeyCode() </seealso>
		/// <seealso cref= #getKeyChar() </seealso>
		public KeyEvent(Component source, int id, long when, int modifiers, int keyCode, char keyChar) : this(source, id, when, modifiers, keyCode, keyChar, KEY_LOCATION_UNKNOWN)
		{
		}

		/// @deprecated as of JDK1.1 
		[Obsolete("as of JDK1.1")]
		public KeyEvent(Component source, int id, long when, int modifiers, int keyCode) : this(source, id, when, modifiers, keyCode, (char)keyCode)
		{
		}

		/// <summary>
		/// Returns the integer keyCode associated with the key in this event.
		/// </summary>
		/// <returns> the integer code for an actual key on the keyboard.
		///         (For <code>KEY_TYPED</code> events, the keyCode is
		///         <code>VK_UNDEFINED</code>.) </returns>
		public virtual int KeyCode
		{
			get
			{
				return KeyCode_Renamed;
			}
			set
			{
				this.KeyCode_Renamed = value;
			}
		}


		/// <summary>
		/// Returns the character associated with the key in this event.
		/// For example, the <code>KEY_TYPED</code> event for shift + "a"
		/// returns the value for "A".
		/// <para>
		/// <code>KEY_PRESSED</code> and <code>KEY_RELEASED</code> events
		/// are not intended for reporting of character input.  Therefore,
		/// the values returned by this method are guaranteed to be
		/// meaningful only for <code>KEY_TYPED</code> events.
		/// 
		/// </para>
		/// </summary>
		/// <returns> the Unicode character defined for this key event.
		///         If no valid Unicode character exists for this key event,
		///         <code>CHAR_UNDEFINED</code> is returned. </returns>
		public virtual char KeyChar
		{
			get
			{
				return KeyChar_Renamed;
			}
			set
			{
				this.KeyChar_Renamed = value;
			}
		}


		/// <summary>
		/// Set the modifiers to indicate additional keys that were held down
		/// (e.g. shift, ctrl, alt, meta) defined as part of InputEvent.
		/// <para>
		/// NOTE:  use of this method is not recommended, because many AWT
		/// implementations do not recognize modifier changes.  This is
		/// especially true for <code>KEY_TYPED</code> events where the shift
		/// modifier is changed.
		/// 
		/// </para>
		/// </summary>
		/// <param name="modifiers"> an integer combination of the modifier constants. </param>
		/// <seealso cref= InputEvent </seealso>
		/// @deprecated as of JDK1.1.4 
		[Obsolete("as of JDK1.1.4")]
		public virtual int Modifiers
		{
			set
			{
				this.Modifiers_Renamed = value;
				if ((Modifiers != 0) && (ModifiersEx == 0))
				{
					SetNewModifiers();
				}
				else if ((Modifiers == 0) && (ModifiersEx != 0))
				{
					SetOldModifiers();
				}
			}
		}

		/// <summary>
		/// Returns the location of the key that originated this key event.
		/// 
		/// Some keys occur more than once on a keyboard, e.g. the left and
		/// right shift keys.  Additionally, some keys occur on the numeric
		/// keypad.  This provides a way of distinguishing such keys.
		/// </summary>
		/// <returns> the location of the key that was pressed or released.
		///         Always returns <code>KEY_LOCATION_UNKNOWN</code> for
		///         <code>KEY_TYPED</code> events.
		/// @since 1.4 </returns>
		public virtual int KeyLocation
		{
			get
			{
				return KeyLocation_Renamed;
			}
		}

		/// <summary>
		/// Returns a String describing the keyCode, such as "HOME", "F1" or "A".
		/// These strings can be localized by changing the awt.properties file.
		/// </summary>
		/// <returns> a string containing a text description for a physical key,
		///         identified by its keyCode </returns>
		public static String GetKeyText(int keyCode)
		{
			if (keyCode >= VK_0 && keyCode <= VK_9 || keyCode >= VK_A && keyCode <= VK_Z)
			{
				return Convert.ToString((char)keyCode);
			}

			switch (keyCode)
			{
			  case VK_ENTER:
				  return Toolkit.GetProperty("AWT.enter", "Enter");
			  case VK_BACK_SPACE:
				  return Toolkit.GetProperty("AWT.backSpace", "Backspace");
			  case VK_TAB:
				  return Toolkit.GetProperty("AWT.tab", "Tab");
			  case VK_CANCEL:
				  return Toolkit.GetProperty("AWT.cancel", "Cancel");
			  case VK_CLEAR:
				  return Toolkit.GetProperty("AWT.clear", "Clear");
			  case VK_COMPOSE:
				  return Toolkit.GetProperty("AWT.compose", "Compose");
			  case VK_PAUSE:
				  return Toolkit.GetProperty("AWT.pause", "Pause");
			  case VK_CAPS_LOCK:
				  return Toolkit.GetProperty("AWT.capsLock", "Caps Lock");
			  case VK_ESCAPE:
				  return Toolkit.GetProperty("AWT.escape", "Escape");
			  case VK_SPACE:
				  return Toolkit.GetProperty("AWT.space", "Space");
			  case VK_PAGE_UP:
				  return Toolkit.GetProperty("AWT.pgup", "Page Up");
			  case VK_PAGE_DOWN:
				  return Toolkit.GetProperty("AWT.pgdn", "Page Down");
			  case VK_END:
				  return Toolkit.GetProperty("AWT.end", "End");
			  case VK_HOME:
				  return Toolkit.GetProperty("AWT.home", "Home");
			  case VK_LEFT:
				  return Toolkit.GetProperty("AWT.left", "Left");
			  case VK_UP:
				  return Toolkit.GetProperty("AWT.up", "Up");
			  case VK_RIGHT:
				  return Toolkit.GetProperty("AWT.right", "Right");
			  case VK_DOWN:
				  return Toolkit.GetProperty("AWT.down", "Down");
			  case VK_BEGIN:
				  return Toolkit.GetProperty("AWT.begin", "Begin");

			  // modifiers
			  case VK_SHIFT:
				  return Toolkit.GetProperty("AWT.shift", "Shift");
			  case VK_CONTROL:
				  return Toolkit.GetProperty("AWT.control", "Control");
			  case VK_ALT:
				  return Toolkit.GetProperty("AWT.alt", "Alt");
			  case VK_META:
				  return Toolkit.GetProperty("AWT.meta", "Meta");
			  case VK_ALT_GRAPH:
				  return Toolkit.GetProperty("AWT.altGraph", "Alt Graph");

			  // punctuation
			  case VK_COMMA:
				  return Toolkit.GetProperty("AWT.comma", "Comma");
			  case VK_PERIOD:
				  return Toolkit.GetProperty("AWT.period", "Period");
			  case VK_SLASH:
				  return Toolkit.GetProperty("AWT.slash", "Slash");
			  case VK_SEMICOLON:
				  return Toolkit.GetProperty("AWT.semicolon", "Semicolon");
			  case VK_EQUALS:
				  return Toolkit.GetProperty("AWT.equals", "Equals");
			  case VK_OPEN_BRACKET:
				  return Toolkit.GetProperty("AWT.openBracket", "Open Bracket");
			  case VK_BACK_SLASH:
				  return Toolkit.GetProperty("AWT.backSlash", "Back Slash");
			  case VK_CLOSE_BRACKET:
				  return Toolkit.GetProperty("AWT.closeBracket", "Close Bracket");

			  // numpad numeric keys handled below
			  case VK_MULTIPLY:
				  return Toolkit.GetProperty("AWT.multiply", "NumPad *");
			  case VK_ADD:
				  return Toolkit.GetProperty("AWT.add", "NumPad +");
			  case VK_SEPARATOR:
				  return Toolkit.GetProperty("AWT.separator", "NumPad ,");
			  case VK_SUBTRACT:
				  return Toolkit.GetProperty("AWT.subtract", "NumPad -");
			  case VK_DECIMAL:
				  return Toolkit.GetProperty("AWT.decimal", "NumPad .");
			  case VK_DIVIDE:
				  return Toolkit.GetProperty("AWT.divide", "NumPad /");
			  case VK_DELETE:
				  return Toolkit.GetProperty("AWT.delete", "Delete");
			  case VK_NUM_LOCK:
				  return Toolkit.GetProperty("AWT.numLock", "Num Lock");
			  case VK_SCROLL_LOCK:
				  return Toolkit.GetProperty("AWT.scrollLock", "Scroll Lock");

			  case VK_WINDOWS:
				  return Toolkit.GetProperty("AWT.windows", "Windows");
			  case VK_CONTEXT_MENU:
				  return Toolkit.GetProperty("AWT.context", "Context Menu");

			  case VK_F1:
				  return Toolkit.GetProperty("AWT.f1", "F1");
			  case VK_F2:
				  return Toolkit.GetProperty("AWT.f2", "F2");
			  case VK_F3:
				  return Toolkit.GetProperty("AWT.f3", "F3");
			  case VK_F4:
				  return Toolkit.GetProperty("AWT.f4", "F4");
			  case VK_F5:
				  return Toolkit.GetProperty("AWT.f5", "F5");
			  case VK_F6:
				  return Toolkit.GetProperty("AWT.f6", "F6");
			  case VK_F7:
				  return Toolkit.GetProperty("AWT.f7", "F7");
			  case VK_F8:
				  return Toolkit.GetProperty("AWT.f8", "F8");
			  case VK_F9:
				  return Toolkit.GetProperty("AWT.f9", "F9");
			  case VK_F10:
				  return Toolkit.GetProperty("AWT.f10", "F10");
			  case VK_F11:
				  return Toolkit.GetProperty("AWT.f11", "F11");
			  case VK_F12:
				  return Toolkit.GetProperty("AWT.f12", "F12");
			  case VK_F13:
				  return Toolkit.GetProperty("AWT.f13", "F13");
			  case VK_F14:
				  return Toolkit.GetProperty("AWT.f14", "F14");
			  case VK_F15:
				  return Toolkit.GetProperty("AWT.f15", "F15");
			  case VK_F16:
				  return Toolkit.GetProperty("AWT.f16", "F16");
			  case VK_F17:
				  return Toolkit.GetProperty("AWT.f17", "F17");
			  case VK_F18:
				  return Toolkit.GetProperty("AWT.f18", "F18");
			  case VK_F19:
				  return Toolkit.GetProperty("AWT.f19", "F19");
			  case VK_F20:
				  return Toolkit.GetProperty("AWT.f20", "F20");
			  case VK_F21:
				  return Toolkit.GetProperty("AWT.f21", "F21");
			  case VK_F22:
				  return Toolkit.GetProperty("AWT.f22", "F22");
			  case VK_F23:
				  return Toolkit.GetProperty("AWT.f23", "F23");
			  case VK_F24:
				  return Toolkit.GetProperty("AWT.f24", "F24");

			  case VK_PRINTSCREEN:
				  return Toolkit.GetProperty("AWT.printScreen", "Print Screen");
			  case VK_INSERT:
				  return Toolkit.GetProperty("AWT.insert", "Insert");
			  case VK_HELP:
				  return Toolkit.GetProperty("AWT.help", "Help");
			  case VK_BACK_QUOTE:
				  return Toolkit.GetProperty("AWT.backQuote", "Back Quote");
			  case VK_QUOTE:
				  return Toolkit.GetProperty("AWT.quote", "Quote");

			  case VK_KP_UP:
				  return Toolkit.GetProperty("AWT.up", "Up");
			  case VK_KP_DOWN:
				  return Toolkit.GetProperty("AWT.down", "Down");
			  case VK_KP_LEFT:
				  return Toolkit.GetProperty("AWT.left", "Left");
			  case VK_KP_RIGHT:
				  return Toolkit.GetProperty("AWT.right", "Right");

			  case VK_DEAD_GRAVE:
				  return Toolkit.GetProperty("AWT.deadGrave", "Dead Grave");
			  case VK_DEAD_ACUTE:
				  return Toolkit.GetProperty("AWT.deadAcute", "Dead Acute");
			  case VK_DEAD_CIRCUMFLEX:
				  return Toolkit.GetProperty("AWT.deadCircumflex", "Dead Circumflex");
			  case VK_DEAD_TILDE:
				  return Toolkit.GetProperty("AWT.deadTilde", "Dead Tilde");
			  case VK_DEAD_MACRON:
				  return Toolkit.GetProperty("AWT.deadMacron", "Dead Macron");
			  case VK_DEAD_BREVE:
				  return Toolkit.GetProperty("AWT.deadBreve", "Dead Breve");
			  case VK_DEAD_ABOVEDOT:
				  return Toolkit.GetProperty("AWT.deadAboveDot", "Dead Above Dot");
			  case VK_DEAD_DIAERESIS:
				  return Toolkit.GetProperty("AWT.deadDiaeresis", "Dead Diaeresis");
			  case VK_DEAD_ABOVERING:
				  return Toolkit.GetProperty("AWT.deadAboveRing", "Dead Above Ring");
			  case VK_DEAD_DOUBLEACUTE:
				  return Toolkit.GetProperty("AWT.deadDoubleAcute", "Dead Double Acute");
			  case VK_DEAD_CARON:
				  return Toolkit.GetProperty("AWT.deadCaron", "Dead Caron");
			  case VK_DEAD_CEDILLA:
				  return Toolkit.GetProperty("AWT.deadCedilla", "Dead Cedilla");
			  case VK_DEAD_OGONEK:
				  return Toolkit.GetProperty("AWT.deadOgonek", "Dead Ogonek");
			  case VK_DEAD_IOTA:
				  return Toolkit.GetProperty("AWT.deadIota", "Dead Iota");
			  case VK_DEAD_VOICED_SOUND:
				  return Toolkit.GetProperty("AWT.deadVoicedSound", "Dead Voiced Sound");
			  case VK_DEAD_SEMIVOICED_SOUND:
				  return Toolkit.GetProperty("AWT.deadSemivoicedSound", "Dead Semivoiced Sound");

			  case VK_AMPERSAND:
				  return Toolkit.GetProperty("AWT.ampersand", "Ampersand");
			  case VK_ASTERISK:
				  return Toolkit.GetProperty("AWT.asterisk", "Asterisk");
			  case VK_QUOTEDBL:
				  return Toolkit.GetProperty("AWT.quoteDbl", "Double Quote");
			  case VK_LESS:
				  return Toolkit.GetProperty("AWT.Less", "Less");
			  case VK_GREATER:
				  return Toolkit.GetProperty("AWT.greater", "Greater");
			  case VK_BRACELEFT:
				  return Toolkit.GetProperty("AWT.braceLeft", "Left Brace");
			  case VK_BRACERIGHT:
				  return Toolkit.GetProperty("AWT.braceRight", "Right Brace");
			  case VK_AT:
				  return Toolkit.GetProperty("AWT.at", "At");
			  case VK_COLON:
				  return Toolkit.GetProperty("AWT.colon", "Colon");
			  case VK_CIRCUMFLEX:
				  return Toolkit.GetProperty("AWT.circumflex", "Circumflex");
			  case VK_DOLLAR:
				  return Toolkit.GetProperty("AWT.dollar", "Dollar");
			  case VK_EURO_SIGN:
				  return Toolkit.GetProperty("AWT.euro", "Euro");
			  case VK_EXCLAMATION_MARK:
				  return Toolkit.GetProperty("AWT.exclamationMark", "Exclamation Mark");
			  case VK_INVERTED_EXCLAMATION_MARK:
				  return Toolkit.GetProperty("AWT.invertedExclamationMark", "Inverted Exclamation Mark");
			  case VK_LEFT_PARENTHESIS:
				  return Toolkit.GetProperty("AWT.leftParenthesis", "Left Parenthesis");
			  case VK_NUMBER_SIGN:
				  return Toolkit.GetProperty("AWT.numberSign", "Number Sign");
			  case VK_MINUS:
				  return Toolkit.GetProperty("AWT.minus", "Minus");
			  case VK_PLUS:
				  return Toolkit.GetProperty("AWT.plus", "Plus");
			  case VK_RIGHT_PARENTHESIS:
				  return Toolkit.GetProperty("AWT.rightParenthesis", "Right Parenthesis");
			  case VK_UNDERSCORE:
				  return Toolkit.GetProperty("AWT.underscore", "Underscore");

			  case VK_FINAL:
				  return Toolkit.GetProperty("AWT.final", "Final");
			  case VK_CONVERT:
				  return Toolkit.GetProperty("AWT.convert", "Convert");
			  case VK_NONCONVERT:
				  return Toolkit.GetProperty("AWT.noconvert", "No Convert");
			  case VK_ACCEPT:
				  return Toolkit.GetProperty("AWT.accept", "Accept");
			  case VK_MODECHANGE:
				  return Toolkit.GetProperty("AWT.modechange", "Mode Change");
			  case VK_KANA:
				  return Toolkit.GetProperty("AWT.kana", "Kana");
			  case VK_KANJI:
				  return Toolkit.GetProperty("AWT.kanji", "Kanji");
			  case VK_ALPHANUMERIC:
				  return Toolkit.GetProperty("AWT.alphanumeric", "Alphanumeric");
			  case VK_KATAKANA:
				  return Toolkit.GetProperty("AWT.katakana", "Katakana");
			  case VK_HIRAGANA:
				  return Toolkit.GetProperty("AWT.hiragana", "Hiragana");
			  case VK_FULL_WIDTH:
				  return Toolkit.GetProperty("AWT.fullWidth", "Full-Width");
			  case VK_HALF_WIDTH:
				  return Toolkit.GetProperty("AWT.halfWidth", "Half-Width");
			  case VK_ROMAN_CHARACTERS:
				  return Toolkit.GetProperty("AWT.romanCharacters", "Roman Characters");
			  case VK_ALL_CANDIDATES:
				  return Toolkit.GetProperty("AWT.allCandidates", "All Candidates");
			  case VK_PREVIOUS_CANDIDATE:
				  return Toolkit.GetProperty("AWT.previousCandidate", "Previous Candidate");
			  case VK_CODE_INPUT:
				  return Toolkit.GetProperty("AWT.codeInput", "Code Input");
			  case VK_JAPANESE_KATAKANA:
				  return Toolkit.GetProperty("AWT.japaneseKatakana", "Japanese Katakana");
			  case VK_JAPANESE_HIRAGANA:
				  return Toolkit.GetProperty("AWT.japaneseHiragana", "Japanese Hiragana");
			  case VK_JAPANESE_ROMAN:
				  return Toolkit.GetProperty("AWT.japaneseRoman", "Japanese Roman");
			  case VK_KANA_LOCK:
				  return Toolkit.GetProperty("AWT.kanaLock", "Kana Lock");
			  case VK_INPUT_METHOD_ON_OFF:
				  return Toolkit.GetProperty("AWT.inputMethodOnOff", "Input Method On/Off");

			  case VK_AGAIN:
				  return Toolkit.GetProperty("AWT.again", "Again");
			  case VK_UNDO:
				  return Toolkit.GetProperty("AWT.undo", "Undo");
			  case VK_COPY:
				  return Toolkit.GetProperty("AWT.copy", "Copy");
			  case VK_PASTE:
				  return Toolkit.GetProperty("AWT.paste", "Paste");
			  case VK_CUT:
				  return Toolkit.GetProperty("AWT.cut", "Cut");
			  case VK_FIND:
				  return Toolkit.GetProperty("AWT.find", "Find");
			  case VK_PROPS:
				  return Toolkit.GetProperty("AWT.props", "Props");
			  case VK_STOP:
				  return Toolkit.GetProperty("AWT.stop", "Stop");
			}

			if (keyCode >= VK_NUMPAD0 && keyCode <= VK_NUMPAD9)
			{
				String numpad = Toolkit.GetProperty("AWT.numpad", "NumPad");
				char c = (char)(keyCode - VK_NUMPAD0 + '0');
				return numpad + "-" + c;
			}

			if ((keyCode & 0x01000000) != 0)
			{
				return Convert.ToString((char)(keyCode ^ 0x01000000));
			}
			String unknown = Toolkit.GetProperty("AWT.unknown", "Unknown");
			return unknown + " keyCode: 0x" + Convert.ToString(keyCode, 16);
		}

		/// <summary>
		/// Returns a <code>String</code> describing the modifier key(s),
		/// such as "Shift", or "Ctrl+Shift".  These strings can be
		/// localized by changing the <code>awt.properties</code> file.
		/// <para>
		/// Note that <code>InputEvent.ALT_MASK</code> and
		/// <code>InputEvent.BUTTON2_MASK</code> have the same value,
		/// so the string "Alt" is returned for both modifiers.  Likewise,
		/// <code>InputEvent.META_MASK</code> and
		/// <code>InputEvent.BUTTON3_MASK</code> have the same value,
		/// so the string "Meta" is returned for both modifiers.
		/// 
		/// </para>
		/// </summary>
		/// <returns> string a text description of the combination of modifier
		///                keys that were held down during the event </returns>
		/// <seealso cref= InputEvent#getModifiersExText(int) </seealso>
		public static String GetKeyModifiersText(int modifiers)
		{
			StringBuilder buf = new StringBuilder();
			if ((modifiers & InputEvent.META_MASK) != 0)
			{
				buf.Append(Toolkit.GetProperty("AWT.meta", "Meta"));
				buf.Append("+");
			}
			if ((modifiers & InputEvent.CTRL_MASK) != 0)
			{
				buf.Append(Toolkit.GetProperty("AWT.control", "Ctrl"));
				buf.Append("+");
			}
			if ((modifiers & InputEvent.ALT_MASK) != 0)
			{
				buf.Append(Toolkit.GetProperty("AWT.alt", "Alt"));
				buf.Append("+");
			}
			if ((modifiers & InputEvent.SHIFT_MASK) != 0)
			{
				buf.Append(Toolkit.GetProperty("AWT.shift", "Shift"));
				buf.Append("+");
			}
			if ((modifiers & InputEvent.ALT_GRAPH_MASK) != 0)
			{
				buf.Append(Toolkit.GetProperty("AWT.altGraph", "Alt Graph"));
				buf.Append("+");
			}
			if ((modifiers & InputEvent.BUTTON1_MASK) != 0)
			{
				buf.Append(Toolkit.GetProperty("AWT.button1", "Button1"));
				buf.Append("+");
			}
			if (buf.Length() > 0)
			{
				buf.Length = buf.Length() - 1; // remove trailing '+'
			}
			return buf.ToString();
		}


		/// <summary>
		/// Returns whether the key in this event is an "action" key.
		/// Typically an action key does not fire a unicode character and is
		/// not a modifier key.
		/// </summary>
		/// <returns> <code>true</code> if the key is an "action" key,
		///         <code>false</code> otherwise </returns>
		public virtual bool ActionKey
		{
			get
			{
				switch (KeyCode_Renamed)
				{
				  case VK_HOME:
				  case VK_END:
				  case VK_PAGE_UP:
				  case VK_PAGE_DOWN:
				  case VK_UP:
				  case VK_DOWN:
				  case VK_LEFT:
				  case VK_RIGHT:
				  case VK_BEGIN:
    
				  case VK_KP_LEFT:
				  case VK_KP_UP:
				  case VK_KP_RIGHT:
				  case VK_KP_DOWN:
    
				  case VK_F1:
				  case VK_F2:
				  case VK_F3:
				  case VK_F4:
				  case VK_F5:
				  case VK_F6:
				  case VK_F7:
				  case VK_F8:
				  case VK_F9:
				  case VK_F10:
				  case VK_F11:
				  case VK_F12:
				  case VK_F13:
				  case VK_F14:
				  case VK_F15:
				  case VK_F16:
				  case VK_F17:
				  case VK_F18:
				  case VK_F19:
				  case VK_F20:
				  case VK_F21:
				  case VK_F22:
				  case VK_F23:
				  case VK_F24:
				  case VK_PRINTSCREEN:
				  case VK_SCROLL_LOCK:
				  case VK_CAPS_LOCK:
				  case VK_NUM_LOCK:
				  case VK_PAUSE:
				  case VK_INSERT:
    
				  case VK_FINAL:
				  case VK_CONVERT:
				  case VK_NONCONVERT:
				  case VK_ACCEPT:
				  case VK_MODECHANGE:
				  case VK_KANA:
				  case VK_KANJI:
				  case VK_ALPHANUMERIC:
				  case VK_KATAKANA:
				  case VK_HIRAGANA:
				  case VK_FULL_WIDTH:
				  case VK_HALF_WIDTH:
				  case VK_ROMAN_CHARACTERS:
				  case VK_ALL_CANDIDATES:
				  case VK_PREVIOUS_CANDIDATE:
				  case VK_CODE_INPUT:
				  case VK_JAPANESE_KATAKANA:
				  case VK_JAPANESE_HIRAGANA:
				  case VK_JAPANESE_ROMAN:
				  case VK_KANA_LOCK:
				  case VK_INPUT_METHOD_ON_OFF:
    
				  case VK_AGAIN:
				  case VK_UNDO:
				  case VK_COPY:
				  case VK_PASTE:
				  case VK_CUT:
				  case VK_FIND:
				  case VK_PROPS:
				  case VK_STOP:
    
				  case VK_HELP:
				  case VK_WINDOWS:
				  case VK_CONTEXT_MENU:
					  return true;
				}
				return false;
			}
		}

		/// <summary>
		/// Returns a parameter string identifying this event.
		/// This method is useful for event logging and for debugging.
		/// </summary>
		/// <returns> a string identifying the event and its attributes </returns>
		public override String ParamString()
		{
			StringBuilder str = new StringBuilder(100);

			switch (Id)
			{
			  case KEY_PRESSED:
				str.Append("KEY_PRESSED");
				break;
			  case KEY_RELEASED:
				str.Append("KEY_RELEASED");
				break;
			  case KEY_TYPED:
				str.Append("KEY_TYPED");
				break;
			  default:
				str.Append("unknown type");
				break;
			}

			str.Append(",keyCode=").Append(KeyCode_Renamed);
			str.Append(",keyText=").Append(GetKeyText(KeyCode_Renamed));

			/* Some keychars don't print well, e.g. escape, backspace,
			 * tab, return, delete, cancel.  Get keyText for the keyCode
			 * instead of the keyChar.
			 */
			str.Append(",keyChar=");
			switch (KeyChar_Renamed)
			{
			  case '\b':
				str.Append(GetKeyText(VK_BACK_SPACE));
				break;
			  case '\t':
				str.Append(GetKeyText(VK_TAB));
				break;
			  case '\n':
				str.Append(GetKeyText(VK_ENTER));
				break;
			  case '\u0018':
				str.Append(GetKeyText(VK_CANCEL));
				break;
			  case '\u001b':
				str.Append(GetKeyText(VK_ESCAPE));
				break;
			  case '\u007f':
				str.Append(GetKeyText(VK_DELETE));
				break;
			  case CHAR_UNDEFINED:
				str.Append(Toolkit.GetProperty("AWT.undefined", "Undefined"));
				str.Append(" keyChar");
				break;
			  default:
				str.Append("'").Append(KeyChar_Renamed).Append("'");
				break;
			}

			if (Modifiers != 0)
			{
				str.Append(",modifiers=").Append(GetKeyModifiersText(Modifiers_Renamed));
			}
			if (ModifiersEx != 0)
			{
				str.Append(",extModifiers=").Append(GetModifiersExText(Modifiers_Renamed));
			}

			str.Append(",keyLocation=");
			switch (KeyLocation_Renamed)
			{
			  case KEY_LOCATION_UNKNOWN:
				str.Append("KEY_LOCATION_UNKNOWN");
				break;
			  case KEY_LOCATION_STANDARD:
				str.Append("KEY_LOCATION_STANDARD");
				break;
			  case KEY_LOCATION_LEFT:
				str.Append("KEY_LOCATION_LEFT");
				break;
			  case KEY_LOCATION_RIGHT:
				str.Append("KEY_LOCATION_RIGHT");
				break;
			  case KEY_LOCATION_NUMPAD:
				str.Append("KEY_LOCATION_NUMPAD");
				break;
			  default:
				str.Append("KEY_LOCATION_UNKNOWN");
				break;
			}
			str.Append(",rawCode=").Append(RawCode);
			str.Append(",primaryLevelUnicode=").Append(PrimaryLevelUnicode);
			str.Append(",scancode=").Append(Scancode);
			str.Append(",extendedKeyCode=0x").Append(ExtendedKeyCode_Renamed.ToString("x"));

			return str.ToString();
		}
		/// <summary>
		/// Returns an extended key code for the event.
		/// The extended key code is a unique id assigned to  a key on the keyboard
		/// just like {@code keyCode}. However, unlike {@code keyCode}, this value depends on the
		/// current keyboard layout. For instance, pressing the left topmost letter key
		/// in a common English layout produces the same value as {@code keyCode}, {@code VK_Q}.
		/// Pressing the same key in a regular Russian layout gives another code, unique for the
		/// letter "Cyrillic I short".
		/// 
		/// @since 1.7
		/// 
		/// </summary>
		public virtual int ExtendedKeyCode
		{
			get
			{
				return (int)ExtendedKeyCode_Renamed;
			}
		}
		/// <summary>
		/// Returns an extended key code for a unicode character.
		/// </summary>
		/// <returns> for a unicode character with a corresponding {@code VK_} constant -- this
		///   {@code VK_} constant; for a character appearing on the primary
		///   level of a known keyboard layout -- a unique integer.
		///   If a character does not appear on the primary level of a known keyboard,
		///   {@code VK_UNDEFINED} is returned.
		/// 
		/// @since 1.7
		///  </returns>
		public static int GetExtendedKeyCodeForChar(int c)
		{
			// Return a keycode (if any) associated with a character.
			return sun.awt.ExtendedKeyCodes.getExtendedKeyCodeForChar(c);
		}

		/// <summary>
		/// Sets new modifiers by the old ones. The key modifiers
		/// override overlaping mouse modifiers.
		/// </summary>
		private void SetNewModifiers()
		{
			if ((Modifiers_Renamed & SHIFT_MASK) != 0)
			{
				Modifiers_Renamed |= SHIFT_DOWN_MASK;
			}
			if ((Modifiers_Renamed & ALT_MASK) != 0)
			{
				Modifiers_Renamed |= ALT_DOWN_MASK;
			}
			if ((Modifiers_Renamed & CTRL_MASK) != 0)
			{
				Modifiers_Renamed |= CTRL_DOWN_MASK;
			}
			if ((Modifiers_Renamed & META_MASK) != 0)
			{
				Modifiers_Renamed |= META_DOWN_MASK;
			}
			if ((Modifiers_Renamed & ALT_GRAPH_MASK) != 0)
			{
				Modifiers_Renamed |= ALT_GRAPH_DOWN_MASK;
			}
			if ((Modifiers_Renamed & BUTTON1_MASK) != 0)
			{
				Modifiers_Renamed |= BUTTON1_DOWN_MASK;
			}
		}

		/// <summary>
		/// Sets old modifiers by the new ones.
		/// </summary>
		private void SetOldModifiers()
		{
			if ((Modifiers_Renamed & SHIFT_DOWN_MASK) != 0)
			{
				Modifiers_Renamed |= SHIFT_MASK;
			}
			if ((Modifiers_Renamed & ALT_DOWN_MASK) != 0)
			{
				Modifiers_Renamed |= ALT_MASK;
			}
			if ((Modifiers_Renamed & CTRL_DOWN_MASK) != 0)
			{
				Modifiers_Renamed |= CTRL_MASK;
			}
			if ((Modifiers_Renamed & META_DOWN_MASK) != 0)
			{
				Modifiers_Renamed |= META_MASK;
			}
			if ((Modifiers_Renamed & ALT_GRAPH_DOWN_MASK) != 0)
			{
				Modifiers_Renamed |= ALT_GRAPH_MASK;
			}
			if ((Modifiers_Renamed & BUTTON1_DOWN_MASK) != 0)
			{
				Modifiers_Renamed |= BUTTON1_MASK;
			}
		}

		/// <summary>
		/// Sets new modifiers by the old ones. The key modifiers
		/// override overlaping mouse modifiers.
		/// @serial
		/// </summary>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException
		private void ReadObject(ObjectInputStream s)
		{
			s.DefaultReadObject();
			if (Modifiers != 0 && ModifiersEx == 0)
			{
				SetNewModifiers();
			}
		}
	}

}