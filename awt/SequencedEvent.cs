using System;
using System.Collections.Generic;
using System.Threading;

/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

namespace java.awt
{

	using AWTAccessor = sun.awt.AWTAccessor;
	using AppContext = sun.awt.AppContext;
	using SunToolkit = sun.awt.SunToolkit;

	/// <summary>
	/// A mechanism for ensuring that a series of AWTEvents are executed in a
	/// precise order, even across multiple AppContexts. The nested events will be
	/// dispatched in the order in which their wrapping SequencedEvents were
	/// constructed. The only exception to this rule is if the peer of the target of
	/// the nested event was destroyed (with a call to Component.removeNotify)
	/// before the wrapping SequencedEvent was able to be dispatched. In this case,
	/// the nested event is never dispatched.
	/// 
	/// @author David Mendenhall
	/// </summary>
	internal class SequencedEvent : AWTEvent, ActiveEvent
	{
		/*
		 * serialVersionUID
		 */
		private const long SerialVersionUID = 547742659238625067L;

		private static readonly int ID = java.awt.@event.FocusEvent.FOCUS_LAST + 1;
		private static readonly LinkedList<SequencedEvent> List = new LinkedList<SequencedEvent>();

		private readonly AWTEvent Nested;
		private AppContext AppContext;
		private bool Disposed;

		static SequencedEvent()
		{
			AWTAccessor.SequencedEventAccessor = new SequencedEventAccessorAnonymousInnerClassHelper();
		}

		private class SequencedEventAccessorAnonymousInnerClassHelper : AWTAccessor.SequencedEventAccessor
		{
			public SequencedEventAccessorAnonymousInnerClassHelper()
			{
			}

			public virtual AWTEvent GetNested(AWTEvent sequencedEvent)
			{
				return ((SequencedEvent)sequencedEvent).Nested;
			}
			public virtual bool IsSequencedEvent(AWTEvent @event)
			{
				return @event is SequencedEvent;
			}
		}

		/// <summary>
		/// Constructs a new SequencedEvent which will dispatch the specified
		/// nested event.
		/// </summary>
		/// <param name="nested"> the AWTEvent which this SequencedEvent's dispatch()
		///        method will dispatch </param>
		public SequencedEvent(AWTEvent nested) : base(nested.Source, ID)
		{
			this.Nested = nested;
			// All AWTEvents that are wrapped in SequencedEvents are (at
			// least currently) implicitly generated by the system
			SunToolkit.SystemGenerated = nested;
			lock (typeof(SequencedEvent))
			{
				List.Add(this);
			}
		}

		/// <summary>
		/// Dispatches the nested event after all previous nested events have been
		/// dispatched or disposed. If this method is invoked before all previous nested events
		/// have been dispatched, then this method blocks until such a point is
		/// reached.
		/// While waiting disposes nested events to disposed AppContext
		/// 
		/// NOTE: Locking protocol.  Since dispose() can get EventQueue lock,
		/// dispatch() shall never call dispose() while holding the lock on the list,
		/// as EventQueue lock is held during dispatching.  The locks should be acquired
		/// in the same order.
		/// </summary>
		public void Dispatch()
		{
			try
			{
				AppContext = AppContext.AppContext;

				if (First != this)
				{
					if (EventQueue.DispatchThread)
					{
						EventDispatchThread edt = (EventDispatchThread) Thread.CurrentThread;
						edt.PumpEvents(SentEvent.ID, new ConditionalAnonymousInnerClassHelper(this));
					}
					else
					{
						while (!FirstOrDisposed)
						{
							lock (typeof(SequencedEvent))
							{
								try
								{
									Monitor.Wait(typeof(SequencedEvent), TimeSpan.FromMilliseconds(1000));
								}
								catch (InterruptedException)
								{
									break;
								}
							}
						}
					}
				}

				if (!Disposed)
				{
					KeyboardFocusManager.CurrentKeyboardFocusManager.CurrentSequencedEvent = this;
					Toolkit.EventQueue.DispatchEvent(Nested);
				}
			}
			finally
			{
				Dispose();
			}
		}

		private class ConditionalAnonymousInnerClassHelper : Conditional
		{
			private readonly SequencedEvent OuterInstance;

			public ConditionalAnonymousInnerClassHelper(SequencedEvent outerInstance)
			{
				this.OuterInstance = outerInstance;
			}

			public virtual bool Evaluate()
			{
				return !OuterInstance.FirstOrDisposed;
			}
		}

		/// <summary>
		/// true only if event exists and nested source appContext is disposed.
		/// </summary>
		private static bool IsOwnerAppContextDisposed(SequencedEvent se)
		{
			if (se != null)
			{
				Object target = se.Nested.Source;
				if (target is Component)
				{
					return ((Component)target).AppContext.Disposed;
				}
			}
			return false;
		}

		/// <summary>
		/// Sequenced events are dispatched in order, so we cannot dispatch
		/// until we are the first sequenced event in the queue (i.e. it's our
		/// turn).  But while we wait for our turn to dispatch, the event
		/// could have been disposed for a number of reasons.
		/// </summary>
		public bool FirstOrDisposed
		{
			get
			{
				if (Disposed)
				{
					return true;
				}
				// getFirstWithContext can dispose this
				return this == FirstWithContext || Disposed;
			}
		}

		private static SequencedEvent First
		{
			get
			{
				lock (typeof(SequencedEvent))
				{
					return (SequencedEvent)List.First;
				}
			}
		}

		/* Disposes all events from disposed AppContext
		 * return first valid event
		 */
		private static SequencedEvent FirstWithContext
		{
			get
			{
				SequencedEvent first = First;
				while (IsOwnerAppContextDisposed(first))
				{
					first.Dispose();
					first = First;
				}
				return first;
			}
		}

		/// <summary>
		/// Disposes of this instance. This method is invoked once the nested event
		/// has been dispatched and handled, or when the peer of the target of the
		/// nested event has been disposed with a call to Component.removeNotify.
		/// 
		/// NOTE: Locking protocol.  Since SunToolkit.postEvent can get EventQueue lock,
		/// it shall never be called while holding the lock on the list,
		/// as EventQueue lock is held during dispatching and dispatch() will get
		/// lock on the list. The locks should be acquired in the same order.
		/// </summary>
		internal void Dispose()
		{
		  lock (typeof(SequencedEvent))
		  {
				if (Disposed)
				{
					return;
				}
				if (KeyboardFocusManager.CurrentKeyboardFocusManager.CurrentSequencedEvent == this)
				{
					KeyboardFocusManager.CurrentKeyboardFocusManager.CurrentSequencedEvent = null;
				}
				Disposed = true;
		  }
			// Wake myself up
			if (AppContext != null)
			{
				SunToolkit.postEvent(AppContext, new SentEvent());
			}

			SequencedEvent next = null;

			lock (typeof(SequencedEvent))
			{
			  Monitor.PulseAll(typeof(SequencedEvent));

			  if (List.First == this)
			  {
				  List.RemoveFirst();

				  if (!List.Empty)
				  {
						next = (SequencedEvent)List.First;
				  }
			  }
			  else
			  {
				  List.Remove(this);
			  }
			}
			// Wake up waiting threads
			if (next != null && next.AppContext != null)
			{
				SunToolkit.postEvent(next.AppContext, new SentEvent());
			}
		}
	}

}