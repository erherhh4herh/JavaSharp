using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;

/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
namespace java.awt
{







	using PlatformLogger = sun.util.logging.PlatformLogger;

	using AppContext = sun.awt.AppContext;
	using SunToolkit = sun.awt.SunToolkit;
	using CausedFocusEvent = sun.awt.CausedFocusEvent;
	using KeyboardFocusManagerPeerProvider = sun.awt.KeyboardFocusManagerPeerProvider;
	using AWTAccessor = sun.awt.AWTAccessor;

	/// <summary>
	/// The KeyboardFocusManager is responsible for managing the active and focused
	/// Windows, and the current focus owner. The focus owner is defined as the
	/// Component in an application that will typically receive all KeyEvents
	/// generated by the user. The focused Window is the Window that is, or
	/// contains, the focus owner. Only a Frame or a Dialog can be the active
	/// Window. The native windowing system may denote the active Window or its
	/// children with special decorations, such as a highlighted title bar. The
	/// active Window is always either the focused Window, or the first Frame or
	/// Dialog that is an owner of the focused Window.
	/// <para>
	/// The KeyboardFocusManager is both a centralized location for client code to
	/// query for the focus owner and initiate focus changes, and an event
	/// dispatcher for all FocusEvents, WindowEvents related to focus, and
	/// KeyEvents.
	/// </para>
	/// <para>
	/// Some browsers partition applets in different code bases into separate
	/// contexts, and establish walls between these contexts. In such a scenario,
	/// there will be one KeyboardFocusManager per context. Other browsers place all
	/// applets into the same context, implying that there will be only a single,
	/// global KeyboardFocusManager for all applets. This behavior is
	/// implementation-dependent. Consult your browser's documentation for more
	/// information. No matter how many contexts there may be, however, there can
	/// never be more than one focus owner, focused Window, or active Window, per
	/// ClassLoader.
	/// </para>
	/// <para>
	/// Please see
	/// <a href="https://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html">
	/// How to Use the Focus Subsystem</a>,
	/// a section in <em>The Java Tutorial</em>, and the
	/// <a href="../../java/awt/doc-files/FocusSpec.html">Focus Specification</a>
	/// for more information.
	/// 
	/// @author David Mendenhall
	/// 
	/// </para>
	/// </summary>
	/// <seealso cref= Window </seealso>
	/// <seealso cref= Frame </seealso>
	/// <seealso cref= Dialog </seealso>
	/// <seealso cref= java.awt.event.FocusEvent </seealso>
	/// <seealso cref= java.awt.event.WindowEvent </seealso>
	/// <seealso cref= java.awt.event.KeyEvent
	/// @since 1.4 </seealso>
	public abstract class KeyboardFocusManager : KeyEventDispatcher, KeyEventPostProcessor
	{

		// Shared focus engine logger
		private static readonly PlatformLogger FocusLog = PlatformLogger.getLogger("java.awt.focus.KeyboardFocusManager");

		static KeyboardFocusManager()
		{
			/* ensure that the necessary native libraries are loaded */
			Toolkit.LoadLibraries();
			if (!GraphicsEnvironment.Headless)
			{
				initIDs();
			}
			AWTAccessor.setKeyboardFocusManagerAccessor(new KeyboardFocusManagerAccessorAnonymousInnerClassHelper()
		   );
		}

		private class KeyboardFocusManagerAccessorAnonymousInnerClassHelper : AWTAccessor.KeyboardFocusManagerAccessor
		{
			public KeyboardFocusManagerAccessorAnonymousInnerClassHelper()
			{
			}

			public virtual int ShouldNativelyFocusHeavyweight(Component heavyweight, Component descendant, bool temporary, bool focusedWindowChangeAllowed, long time, CausedFocusEvent.Cause cause)
			{
				return KeyboardFocusManager.ShouldNativelyFocusHeavyweight(heavyweight, descendant, temporary, focusedWindowChangeAllowed, time, cause);
			}
			public virtual bool ProcessSynchronousLightweightTransfer(Component heavyweight, Component descendant, bool temporary, bool focusedWindowChangeAllowed, long time)
			{
				return KeyboardFocusManager.ProcessSynchronousLightweightTransfer(heavyweight, descendant, temporary, focusedWindowChangeAllowed, time);
			}
			public virtual void RemoveLastFocusRequest(Component heavyweight)
			{
				KeyboardFocusManager.RemoveLastFocusRequest(heavyweight);
			}
			public virtual void SetMostRecentFocusOwner(Window window, Component component)
			{
				KeyboardFocusManager.SetMostRecentFocusOwner(window, component);
			}
			public virtual KeyboardFocusManager GetCurrentKeyboardFocusManager(AppContext ctx)
			{
				return KeyboardFocusManager.GetCurrentKeyboardFocusManager(ctx);
			}
			public virtual Container CurrentFocusCycleRoot
			{
				get
				{
					return KeyboardFocusManager.CurrentFocusCycleRoot_Renamed;
				}
			}
		}

		[NonSerialized]
		internal KeyboardFocusManagerPeer Peer;

		/// <summary>
		/// Initialize JNI field and method IDs
		/// </summary>
//JAVA TO C# CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		[DllImport("unknown")]
		private static extern void initIDs();

		private static readonly PlatformLogger Log = PlatformLogger.getLogger("java.awt.KeyboardFocusManager");

		/// <summary>
		/// The identifier for the Forward focus traversal keys.
		/// </summary>
		/// <seealso cref= #setDefaultFocusTraversalKeys </seealso>
		/// <seealso cref= #getDefaultFocusTraversalKeys </seealso>
		/// <seealso cref= Component#setFocusTraversalKeys </seealso>
		/// <seealso cref= Component#getFocusTraversalKeys </seealso>
		public const int FORWARD_TRAVERSAL_KEYS = 0;

		/// <summary>
		/// The identifier for the Backward focus traversal keys.
		/// </summary>
		/// <seealso cref= #setDefaultFocusTraversalKeys </seealso>
		/// <seealso cref= #getDefaultFocusTraversalKeys </seealso>
		/// <seealso cref= Component#setFocusTraversalKeys </seealso>
		/// <seealso cref= Component#getFocusTraversalKeys </seealso>
		public const int BACKWARD_TRAVERSAL_KEYS = 1;

		/// <summary>
		/// The identifier for the Up Cycle focus traversal keys.
		/// </summary>
		/// <seealso cref= #setDefaultFocusTraversalKeys </seealso>
		/// <seealso cref= #getDefaultFocusTraversalKeys </seealso>
		/// <seealso cref= Component#setFocusTraversalKeys </seealso>
		/// <seealso cref= Component#getFocusTraversalKeys </seealso>
		public const int UP_CYCLE_TRAVERSAL_KEYS = 2;

		/// <summary>
		/// The identifier for the Down Cycle focus traversal keys.
		/// </summary>
		/// <seealso cref= #setDefaultFocusTraversalKeys </seealso>
		/// <seealso cref= #getDefaultFocusTraversalKeys </seealso>
		/// <seealso cref= Component#setFocusTraversalKeys </seealso>
		/// <seealso cref= Component#getFocusTraversalKeys </seealso>
		public const int DOWN_CYCLE_TRAVERSAL_KEYS = 3;

		internal static readonly int TRAVERSAL_KEY_LENGTH = DOWN_CYCLE_TRAVERSAL_KEYS + 1;

		/// <summary>
		/// Returns the current KeyboardFocusManager instance for the calling
		/// thread's context.
		/// </summary>
		/// <returns> this thread's context's KeyboardFocusManager </returns>
		/// <seealso cref= #setCurrentKeyboardFocusManager </seealso>
		public static KeyboardFocusManager CurrentKeyboardFocusManager
		{
			get
			{
				return GetCurrentKeyboardFocusManager(AppContext.AppContext);
			}
			set
			{
				CheckReplaceKFMPermission();
    
				KeyboardFocusManager oldManager = null;
    
				lock (typeof(KeyboardFocusManager))
				{
					AppContext appcontext = AppContext.AppContext;
    
					if (value != null)
					{
						oldManager = GetCurrentKeyboardFocusManager(appcontext);
    
						appcontext.put(typeof(KeyboardFocusManager), value);
					}
					else
					{
						oldManager = GetCurrentKeyboardFocusManager(appcontext);
						appcontext.remove(typeof(KeyboardFocusManager));
					}
				}
    
				if (oldManager != null)
				{
					oldManager.FirePropertyChange("managingFocus", true, false);
				}
				if (value != null)
				{
					value.FirePropertyChange("managingFocus", false, true);
				}
			}
		}

		internal static KeyboardFocusManager GetCurrentKeyboardFocusManager(AppContext appcontext)
		{
			lock (typeof(KeyboardFocusManager))
			{
				KeyboardFocusManager manager = (KeyboardFocusManager) appcontext.get(typeof(KeyboardFocusManager));
				if (manager == null)
				{
					manager = new DefaultKeyboardFocusManager();
					appcontext.put(typeof(KeyboardFocusManager), manager);
				}
				return manager;
			}
		}


		/// <summary>
		/// The Component in an application that will typically receive all
		/// KeyEvents generated by the user.
		/// </summary>
		private static Component FocusOwner_Renamed;

		/// <summary>
		/// The Component in an application that will regain focus when an
		/// outstanding temporary focus transfer has completed, or the focus owner,
		/// if no outstanding temporary transfer exists.
		/// </summary>
		private static Component PermanentFocusOwner_Renamed;

		/// <summary>
		/// The Window which is, or contains, the focus owner.
		/// </summary>
		private static Window FocusedWindow_Renamed;

		/// <summary>
		/// Only a Frame or a Dialog can be the active Window. The native windowing
		/// system may denote the active Window with a special decoration, such as a
		/// highlighted title bar. The active Window is always either the focused
		/// Window, or the first Frame or Dialog which is an owner of the focused
		/// Window.
		/// </summary>
		private static Window ActiveWindow_Renamed;

		/// <summary>
		/// The default FocusTraversalPolicy for all Windows that have no policy of
		/// their own set. If those Windows have focus-cycle-root children that have
		/// no keyboard-traversal policy of their own, then those children will also
		/// inherit this policy (as will, recursively, their focus-cycle-root
		/// children).
		/// </summary>
		private FocusTraversalPolicy DefaultPolicy = new DefaultFocusTraversalPolicy();

		/// <summary>
		/// The bound property names of each focus traversal key.
		/// </summary>
		private static readonly String[] DefaultFocusTraversalKeyPropertyNames = new String[] {"forwardDefaultFocusTraversalKeys", "backwardDefaultFocusTraversalKeys", "upCycleDefaultFocusTraversalKeys", "downCycleDefaultFocusTraversalKeys"};

		/// <summary>
		/// The default strokes for initializing the default focus traversal keys.
		/// </summary>
		private static readonly AWTKeyStroke[][] DefaultFocusTraversalKeyStrokes = new AWTKeyStroke[][] {new AWTKeyStroke[] {AWTKeyStroke.GetAWTKeyStroke(KeyEvent.VK_TAB, 0, false), AWTKeyStroke.GetAWTKeyStroke(KeyEvent.VK_TAB, InputEvent.CTRL_DOWN_MASK | InputEvent.CTRL_MASK, false)}, new AWTKeyStroke[] {AWTKeyStroke.GetAWTKeyStroke(KeyEvent.VK_TAB, InputEvent.SHIFT_DOWN_MASK | InputEvent.SHIFT_MASK, false), AWTKeyStroke.GetAWTKeyStroke(KeyEvent.VK_TAB, InputEvent.SHIFT_DOWN_MASK | InputEvent.SHIFT_MASK | InputEvent.CTRL_DOWN_MASK | InputEvent.CTRL_MASK, false)}, new AWTKeyStroke[] {}, new AWTKeyStroke[] {}};
		/// <summary>
		/// The default focus traversal keys. Each array of traversal keys will be
		/// in effect on all Windows that have no such array of their own explicitly
		/// set. Each array will also be inherited, recursively, by any child
		/// Component of those Windows that has no such array of its own explicitly
		/// set.
		/// </summary>
		private Set<AWTKeyStroke>[] DefaultFocusTraversalKeys = new Set[4];

		/// <summary>
		/// The current focus cycle root. If the focus owner is itself a focus cycle
		/// root, then it may be ambiguous as to which Components represent the next
		/// and previous Components to focus during normal focus traversal. In that
		/// case, the current focus cycle root is used to differentiate among the
		/// possibilities.
		/// </summary>
		private static Container CurrentFocusCycleRoot_Renamed;

		/// <summary>
		/// A description of any VetoableChangeListeners which have been registered.
		/// </summary>
		private VetoableChangeSupport VetoableSupport;

		/// <summary>
		/// A description of any PropertyChangeListeners which have been registered.
		/// </summary>
		private PropertyChangeSupport ChangeSupport;

		/// <summary>
		/// This KeyboardFocusManager's KeyEventDispatcher chain. The List does not
		/// include this KeyboardFocusManager unless it was explicitly re-registered
		/// via a call to <code>addKeyEventDispatcher</code>. If no other
		/// KeyEventDispatchers are registered, this field may be null or refer to
		/// a List of length 0.
		/// </summary>
		private LinkedList<KeyEventDispatcher> KeyEventDispatchers_Renamed;

		/// <summary>
		/// This KeyboardFocusManager's KeyEventPostProcessor chain. The List does
		/// not include this KeyboardFocusManager unless it was explicitly
		/// re-registered via a call to <code>addKeyEventPostProcessor</code>.
		/// If no other KeyEventPostProcessors are registered, this field may be
		/// null or refer to a List of length 0.
		/// </summary>
		private LinkedList<KeyEventPostProcessor> KeyEventPostProcessors_Renamed;

		/// <summary>
		/// Maps Windows to those Windows' most recent focus owners.
		/// </summary>
		private static IDictionary<Window, WeakReference<Component>> MostRecentFocusOwners = new WeakHashMap<Window, WeakReference<Component>>();

		/// <summary>
		/// We cache the permission used to verify that the calling thread is
		/// permitted to access the global focus state.
		/// </summary>
		private static AWTPermission ReplaceKeyboardFocusManagerPermission;

		/*
		 * SequencedEvent which is currently dispatched in AppContext.
		 */
		[NonSerialized]
		internal SequencedEvent CurrentSequencedEvent_Renamed = null;

		internal SequencedEvent CurrentSequencedEvent
		{
			set
			{
				lock (typeof(SequencedEvent))
				{
					assert(value == null || CurrentSequencedEvent_Renamed == null);
					CurrentSequencedEvent_Renamed = value;
				}
			}
			get
			{
				lock (typeof(SequencedEvent))
				{
					return CurrentSequencedEvent_Renamed;
				}
			}
		}


		internal static Set<AWTKeyStroke> InitFocusTraversalKeysSet(String value, Set<AWTKeyStroke> targetSet)
		{
			StringTokenizer tokens = new StringTokenizer(value, ",");
			while (tokens.HasMoreTokens())
			{
				targetSet.Add(AWTKeyStroke.GetAWTKeyStroke(tokens.NextToken()));
			}
			return (targetSet.Count == 0) ? Collections.EMPTY_SET : Collections.UnmodifiableSet(targetSet);
		}

		/// <summary>
		/// Initializes a KeyboardFocusManager.
		/// </summary>
		public KeyboardFocusManager()
		{
			for (int i = 0; i < TRAVERSAL_KEY_LENGTH; i++)
			{
				Set<AWTKeyStroke> work_set = new HashSet<AWTKeyStroke>();
				for (int j = 0; j < DefaultFocusTraversalKeyStrokes[i].Length; j++)
				{
					work_set.Add(DefaultFocusTraversalKeyStrokes[i][j]);
				}
				DefaultFocusTraversalKeys[i] = (work_set.Count == 0) ? Collections.EMPTY_SET : Collections.UnmodifiableSet(work_set);
			}
			InitPeer();
		}

		private void InitPeer()
		{
			Toolkit tk = Toolkit.DefaultToolkit;
			KeyboardFocusManagerPeerProvider peerProvider = (KeyboardFocusManagerPeerProvider)tk;
			Peer = peerProvider.KeyboardFocusManagerPeer;
		}

		/// <summary>
		/// Returns the focus owner, if the focus owner is in the same context as
		/// the calling thread. The focus owner is defined as the Component in an
		/// application that will typically receive all KeyEvents generated by the
		/// user. KeyEvents which map to the focus owner's focus traversal keys will
		/// not be delivered if focus traversal keys are enabled for the focus
		/// owner. In addition, KeyEventDispatchers may retarget or consume
		/// KeyEvents before they reach the focus owner.
		/// </summary>
		/// <returns> the focus owner, or null if the focus owner is not a member of
		///         the calling thread's context </returns>
		/// <seealso cref= #getGlobalFocusOwner </seealso>
		/// <seealso cref= #setGlobalFocusOwner </seealso>
		public virtual Component FocusOwner
		{
			get
			{
				lock (typeof(KeyboardFocusManager))
				{
					if (FocusOwner_Renamed == null)
					{
						return null;
					}
    
					return (FocusOwner_Renamed.AppContext == AppContext.AppContext) ? FocusOwner_Renamed : null;
				}
			}
		}

		/// <summary>
		/// Returns the focus owner, even if the calling thread is in a different
		/// context than the focus owner. The focus owner is defined as the
		/// Component in an application that will typically receive all KeyEvents
		/// generated by the user. KeyEvents which map to the focus owner's focus
		/// traversal keys will not be delivered if focus traversal keys are enabled
		/// for the focus owner. In addition, KeyEventDispatchers may retarget or
		/// consume KeyEvents before they reach the focus owner.
		/// <para>
		/// This method will throw a SecurityException if this KeyboardFocusManager
		/// is not the current KeyboardFocusManager for the calling thread's
		/// context.
		/// 
		/// </para>
		/// </summary>
		/// <returns> the focus owner </returns>
		/// <seealso cref= #getFocusOwner </seealso>
		/// <seealso cref= #setGlobalFocusOwner </seealso>
		/// <exception cref="SecurityException"> if this KeyboardFocusManager is not the
		///         current KeyboardFocusManager for the calling thread's context
		///         and if the calling thread does not have "replaceKeyboardFocusManager"
		///         permission </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: protected Component getGlobalFocusOwner() throws SecurityException
		protected internal virtual Component GlobalFocusOwner
		{
			get
			{
				lock (typeof(KeyboardFocusManager))
				{
					CheckKFMSecurity();
					return FocusOwner_Renamed;
				}
			}
			set
			{
				Component oldFocusOwner = null;
				bool shouldFire = false;
    
				if (value == null || value.Focusable)
				{
					lock (typeof(KeyboardFocusManager))
					{
						CheckKFMSecurity();
    
						oldFocusOwner = FocusOwner;
    
						try
						{
							FireVetoableChange("focusOwner", oldFocusOwner, value);
						}
						catch (PropertyVetoException)
						{
							// rejected
							return;
						}
    
						KeyboardFocusManager.FocusOwner_Renamed = value;
    
						if (value != null && (CurrentFocusCycleRoot == null || !value.IsFocusCycleRoot(CurrentFocusCycleRoot)))
						{
							Container rootAncestor = value.FocusCycleRootAncestor;
							if (rootAncestor == null && (value is Window))
							{
								rootAncestor = (Container)value;
							}
							if (rootAncestor != null)
							{
								GlobalCurrentFocusCycleRootPriv = rootAncestor;
							}
						}
    
						shouldFire = true;
					}
				}
    
				if (shouldFire)
				{
					FirePropertyChange("focusOwner", oldFocusOwner, value);
				}
			}
		}


		/// <summary>
		/// Clears the focus owner at both the Java and native levels if the
		/// focus owner exists and resides in the same context as the calling thread,
		/// otherwise the method returns silently.
		/// <para>
		/// The focus owner component will receive a permanent FOCUS_LOST event.
		/// After this operation completes, the native windowing system will discard
		/// all user-generated KeyEvents until the user selects a new Component to
		/// receive focus, or a Component is given focus explicitly via a call to
		/// {@code requestFocus()}. This operation does not change the focused or
		/// active Windows.
		/// 
		/// </para>
		/// </summary>
		/// <seealso cref= Component#requestFocus() </seealso>
		/// <seealso cref= java.awt.event.FocusEvent#FOCUS_LOST
		/// @since 1.8 </seealso>
		public virtual void ClearFocusOwner()
		{
			if (FocusOwner != null)
			{
				ClearGlobalFocusOwner();
			}
		}

		/// <summary>
		/// Clears the global focus owner at both the Java and native levels. If
		/// there exists a focus owner, that Component will receive a permanent
		/// FOCUS_LOST event. After this operation completes, the native windowing
		/// system will discard all user-generated KeyEvents until the user selects
		/// a new Component to receive focus, or a Component is given focus
		/// explicitly via a call to <code>requestFocus()</code>. This operation
		/// does not change the focused or active Windows.
		/// <para>
		/// If a SecurityManager is installed, the calling thread must be granted
		/// the "replaceKeyboardFocusManager" AWTPermission. If this permission is
		/// not granted, this method will throw a SecurityException, and the current
		/// focus owner will not be cleared.
		/// </para>
		/// <para>
		/// This method is intended to be used only by KeyboardFocusManager set as
		/// current KeyboardFocusManager for the calling thread's context. It is not
		/// for general client use.
		/// 
		/// </para>
		/// </summary>
		/// <seealso cref= KeyboardFocusManager#clearFocusOwner </seealso>
		/// <seealso cref= Component#requestFocus() </seealso>
		/// <seealso cref= java.awt.event.FocusEvent#FOCUS_LOST </seealso>
		/// <exception cref="SecurityException"> if the calling thread does not have
		///         "replaceKeyboardFocusManager" permission </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: public void clearGlobalFocusOwner() throws SecurityException
		public virtual void ClearGlobalFocusOwner()
		{
			CheckReplaceKFMPermission();
			if (!GraphicsEnvironment.Headless)
			{
				// Toolkit must be fully initialized, otherwise
				// _clearGlobalFocusOwner will crash or throw an exception
				Toolkit.DefaultToolkit;

				_clearGlobalFocusOwner();
			}
		}
		private void _clearGlobalFocusOwner()
		{
			Window activeWindow = MarkClearGlobalFocusOwner();
			Peer.ClearGlobalFocusOwner(activeWindow);
		}

		internal virtual void ClearGlobalFocusOwnerPriv()
		{
			AccessController.doPrivileged(new PrivilegedActionAnonymousInnerClassHelper(this));
		}

		private class PrivilegedActionAnonymousInnerClassHelper : PrivilegedAction<Void>
		{
			private readonly KeyboardFocusManager OuterInstance;

			public PrivilegedActionAnonymousInnerClassHelper(KeyboardFocusManager outerInstance)
			{
				this.OuterInstance = outerInstance;
			}

			public virtual Void Run()
			{
				outerInstance.ClearGlobalFocusOwner();
				return null;
			}
		}

		internal virtual Component NativeFocusOwner
		{
			get
			{
				return Peer.CurrentFocusOwner;
			}
			set
			{
				if (FocusLog.isLoggable(PlatformLogger.Level.FINEST))
				{
					FocusLog.finest("Calling peer {0} setCurrentFocusOwner for {1}", Convert.ToString(Peer), Convert.ToString(value));
				}
				Peer.CurrentFocusOwner = value;
			}
		}


		internal virtual Window NativeFocusedWindow
		{
			get
			{
				return Peer.CurrentFocusedWindow;
			}
		}

		/// <summary>
		/// Returns the permanent focus owner, if the permanent focus owner is in
		/// the same context as the calling thread. The permanent focus owner is
		/// defined as the last Component in an application to receive a permanent
		/// FOCUS_GAINED event. The focus owner and permanent focus owner are
		/// equivalent unless a temporary focus change is currently in effect. In
		/// such a situation, the permanent focus owner will again be the focus
		/// owner when the temporary focus change ends.
		/// </summary>
		/// <returns> the permanent focus owner, or null if the permanent focus owner
		///         is not a member of the calling thread's context </returns>
		/// <seealso cref= #getGlobalPermanentFocusOwner </seealso>
		/// <seealso cref= #setGlobalPermanentFocusOwner </seealso>
		public virtual Component PermanentFocusOwner
		{
			get
			{
				lock (typeof(KeyboardFocusManager))
				{
					if (PermanentFocusOwner_Renamed == null)
					{
						return null;
					}
    
					return (PermanentFocusOwner_Renamed.AppContext == AppContext.AppContext) ? PermanentFocusOwner_Renamed : null;
				}
			}
		}

		/// <summary>
		/// Returns the permanent focus owner, even if the calling thread is in a
		/// different context than the permanent focus owner. The permanent focus
		/// owner is defined as the last Component in an application to receive a
		/// permanent FOCUS_GAINED event. The focus owner and permanent focus owner
		/// are equivalent unless a temporary focus change is currently in effect.
		/// In such a situation, the permanent focus owner will again be the focus
		/// owner when the temporary focus change ends.
		/// </summary>
		/// <returns> the permanent focus owner </returns>
		/// <seealso cref= #getPermanentFocusOwner </seealso>
		/// <seealso cref= #setGlobalPermanentFocusOwner </seealso>
		/// <exception cref="SecurityException"> if this KeyboardFocusManager is not the
		///         current KeyboardFocusManager for the calling thread's context
		///         and if the calling thread does not have "replaceKeyboardFocusManager"
		///         permission </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: protected Component getGlobalPermanentFocusOwner() throws SecurityException
		protected internal virtual Component GlobalPermanentFocusOwner
		{
			get
			{
				lock (typeof(KeyboardFocusManager))
				{
					CheckKFMSecurity();
					return PermanentFocusOwner_Renamed;
				}
			}
			set
			{
				Component oldPermanentFocusOwner = null;
				bool shouldFire = false;
    
				if (value == null || value.Focusable)
				{
					lock (typeof(KeyboardFocusManager))
					{
						CheckKFMSecurity();
    
						oldPermanentFocusOwner = PermanentFocusOwner;
    
						try
						{
							FireVetoableChange("permanentFocusOwner", oldPermanentFocusOwner, value);
						}
						catch (PropertyVetoException)
						{
							// rejected
							return;
						}
    
						KeyboardFocusManager.PermanentFocusOwner_Renamed = value;
    
						KeyboardFocusManager.MostRecentFocusOwner = value;
    
						shouldFire = true;
					}
				}
    
				if (shouldFire)
				{
					FirePropertyChange("permanentFocusOwner", oldPermanentFocusOwner, value);
				}
			}
		}


		/// <summary>
		/// Returns the focused Window, if the focused Window is in the same context
		/// as the calling thread. The focused Window is the Window that is or
		/// contains the focus owner.
		/// </summary>
		/// <returns> the focused Window, or null if the focused Window is not a
		///         member of the calling thread's context </returns>
		/// <seealso cref= #getGlobalFocusedWindow </seealso>
		/// <seealso cref= #setGlobalFocusedWindow </seealso>
		public virtual Window FocusedWindow
		{
			get
			{
				lock (typeof(KeyboardFocusManager))
				{
					if (FocusedWindow_Renamed == null)
					{
						return null;
					}
    
					return (FocusedWindow_Renamed.AppContext == AppContext.AppContext) ? FocusedWindow_Renamed : null;
				}
			}
		}

		/// <summary>
		/// Returns the focused Window, even if the calling thread is in a different
		/// context than the focused Window. The focused Window is the Window that
		/// is or contains the focus owner.
		/// </summary>
		/// <returns> the focused Window </returns>
		/// <seealso cref= #getFocusedWindow </seealso>
		/// <seealso cref= #setGlobalFocusedWindow </seealso>
		/// <exception cref="SecurityException"> if this KeyboardFocusManager is not the
		///         current KeyboardFocusManager for the calling thread's context
		///         and if the calling thread does not have "replaceKeyboardFocusManager"
		///         permission </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: protected Window getGlobalFocusedWindow() throws SecurityException
		protected internal virtual Window GlobalFocusedWindow
		{
			get
			{
				lock (typeof(KeyboardFocusManager))
				{
					CheckKFMSecurity();
					return FocusedWindow_Renamed;
				}
			}
			set
			{
				Window oldFocusedWindow = null;
				bool shouldFire = false;
    
				if (value == null || value.FocusableWindow)
				{
					lock (typeof(KeyboardFocusManager))
					{
						CheckKFMSecurity();
    
						oldFocusedWindow = FocusedWindow;
    
						try
						{
							FireVetoableChange("focusedWindow", oldFocusedWindow, value);
						}
						catch (PropertyVetoException)
						{
							// rejected
							return;
						}
    
						KeyboardFocusManager.FocusedWindow_Renamed = value;
						shouldFire = true;
					}
				}
    
				if (shouldFire)
				{
					FirePropertyChange("focusedWindow", oldFocusedWindow, value);
				}
			}
		}


		/// <summary>
		/// Returns the active Window, if the active Window is in the same context
		/// as the calling thread. Only a Frame or a Dialog can be the active
		/// Window. The native windowing system may denote the active Window or its
		/// children with special decorations, such as a highlighted title bar.
		/// The active Window is always either the focused Window, or the first
		/// Frame or Dialog that is an owner of the focused Window.
		/// </summary>
		/// <returns> the active Window, or null if the active Window is not a member
		///         of the calling thread's context </returns>
		/// <seealso cref= #getGlobalActiveWindow </seealso>
		/// <seealso cref= #setGlobalActiveWindow </seealso>
		public virtual Window ActiveWindow
		{
			get
			{
				lock (typeof(KeyboardFocusManager))
				{
					if (ActiveWindow_Renamed == null)
					{
						return null;
					}
    
					return (ActiveWindow_Renamed.AppContext == AppContext.AppContext) ? ActiveWindow_Renamed : null;
				}
			}
		}

		/// <summary>
		/// Returns the active Window, even if the calling thread is in a different
		/// context than the active Window. Only a Frame or a Dialog can be the
		/// active Window. The native windowing system may denote the active Window
		/// or its children with special decorations, such as a highlighted title
		/// bar. The active Window is always either the focused Window, or the first
		/// Frame or Dialog that is an owner of the focused Window.
		/// </summary>
		/// <returns> the active Window </returns>
		/// <seealso cref= #getActiveWindow </seealso>
		/// <seealso cref= #setGlobalActiveWindow </seealso>
		/// <exception cref="SecurityException"> if this KeyboardFocusManager is not the
		///         current KeyboardFocusManager for the calling thread's context
		///         and if the calling thread does not have "replaceKeyboardFocusManager"
		///         permission </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: protected Window getGlobalActiveWindow() throws SecurityException
		protected internal virtual Window GlobalActiveWindow
		{
			get
			{
				lock (typeof(KeyboardFocusManager))
				{
					CheckKFMSecurity();
					return ActiveWindow_Renamed;
				}
			}
			set
			{
				Window oldActiveWindow;
				lock (typeof(KeyboardFocusManager))
				{
					CheckKFMSecurity();
    
					oldActiveWindow = ActiveWindow;
					if (FocusLog.isLoggable(PlatformLogger.Level.FINER))
					{
						FocusLog.finer("Setting global active window to " + value + ", old active " + oldActiveWindow);
					}
    
					try
					{
						FireVetoableChange("activeWindow", oldActiveWindow, value);
					}
					catch (PropertyVetoException)
					{
						// rejected
						return;
					}
    
					KeyboardFocusManager.ActiveWindow_Renamed = value;
				}
    
				FirePropertyChange("activeWindow", oldActiveWindow, value);
			}
		}


		/// <summary>
		/// Returns the default FocusTraversalPolicy. Top-level components
		/// use this value on their creation to initialize their own focus traversal
		/// policy by explicit call to Container.setFocusTraversalPolicy.
		/// </summary>
		/// <returns> the default FocusTraversalPolicy. null will never be returned. </returns>
		/// <seealso cref= #setDefaultFocusTraversalPolicy </seealso>
		/// <seealso cref= Container#setFocusTraversalPolicy </seealso>
		/// <seealso cref= Container#getFocusTraversalPolicy </seealso>
		public virtual FocusTraversalPolicy DefaultFocusTraversalPolicy
		{
			get
			{
				lock (this)
				{
					return DefaultPolicy;
				}
			}
			set
			{
				if (value == null)
				{
					throw new IllegalArgumentException("default focus traversal policy cannot be null");
				}
    
				FocusTraversalPolicy oldPolicy;
    
				lock (this)
				{
					oldPolicy = this.DefaultPolicy;
					this.DefaultPolicy = value;
				}
    
				FirePropertyChange("defaultFocusTraversalPolicy", oldPolicy, value);
			}
		}


		/// <summary>
		/// Sets the default focus traversal keys for a given traversal operation.
		/// This traversal key {@code Set} will be in effect on all
		/// {@code Window}s that have no such {@code Set} of
		/// their own explicitly defined. This {@code Set} will also be
		/// inherited, recursively, by any child {@code Component} of
		/// those {@code Windows} that has
		/// no such {@code Set} of its own explicitly defined.
		/// <para>
		/// The default values for the default focus traversal keys are
		/// implementation-dependent. Sun recommends that all implementations for a
		/// particular native platform use the same default values. The
		/// recommendations for Windows and Unix are listed below. These
		/// recommendations are used in the Sun AWT implementations.
		/// 
		/// <table border=1 summary="Recommended default values for focus traversal keys">
		/// <tr>
		///    <th>Identifier</th>
		///    <th>Meaning</th>
		///    <th>Default</th>
		/// </tr>
		/// <tr>
		///    <td>{@code KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS}</td>
		///    <td>Normal forward keyboard traversal</td>
		///    <td>{@code TAB} on {@code KEY_PRESSED},
		///        {@code CTRL-TAB} on {@code KEY_PRESSED}</td>
		/// </tr>
		/// <tr>
		///    <td>{@code KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS}</td>
		///    <td>Normal reverse keyboard traversal</td>
		///    <td>{@code SHIFT-TAB} on {@code KEY_PRESSED},
		///        {@code CTRL-SHIFT-TAB} on {@code KEY_PRESSED}</td>
		/// </tr>
		/// <tr>
		///    <td>{@code KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS}</td>
		///    <td>Go up one focus traversal cycle</td>
		///    <td>none</td>
		/// </tr>
		/// <tr>
		///    <td>{@code KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS}</td>
		///    <td>Go down one focus traversal cycle</td>
		///    <td>none</td>
		/// </tr>
		/// </table>
		/// 
		/// To disable a traversal key, use an empty {@code Set};
		/// {@code Collections.EMPTY_SET} is recommended.
		/// </para>
		/// <para>
		/// Using the {@code AWTKeyStroke} API, client code can
		/// specify on which of two
		/// specific {@code KeyEvent}s, {@code KEY_PRESSED} or
		/// {@code KEY_RELEASED}, the focus traversal operation will
		/// occur. Regardless of which {@code KeyEvent} is specified,
		/// however, all {@code KeyEvent}s related to the focus
		/// traversal key, including the associated {@code KEY_TYPED}
		/// event, will be consumed, and will not be dispatched
		/// to any {@code Component}. It is a runtime error to
		/// specify a {@code KEY_TYPED} event as
		/// mapping to a focus traversal operation, or to map the same event to
		/// multiple default focus traversal operations.
		/// </para>
		/// <para>
		/// This method may throw a {@code ClassCastException} if any {@code Object}
		/// in {@code keystrokes} is not an {@code AWTKeyStroke}.
		/// 
		/// </para>
		/// </summary>
		/// <param name="id"> one of
		///        {@code KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS},
		///        {@code KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS},
		///        {@code KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS}, or
		///        {@code KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS} </param>
		/// <param name="keystrokes"> the Set of {@code AWTKeyStroke}s for the
		///        specified operation </param>
		/// <seealso cref= #getDefaultFocusTraversalKeys </seealso>
		/// <seealso cref= Component#setFocusTraversalKeys </seealso>
		/// <seealso cref= Component#getFocusTraversalKeys </seealso>
		/// <exception cref="IllegalArgumentException"> if id is not one of
		///         {@code KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS},
		///         {@code KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS},
		///         {@code KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS}, or
		///         {@code KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS},
		///         or if keystrokes is {@code null},
		///         or if keystrokes contains {@code null},
		///         or if any keystroke
		///         represents a {@code KEY_TYPED} event,
		///         or if any keystroke already maps
		///         to another default focus traversal operation
		/// @beaninfo
		///       bound: true </exception>
		public virtual void setDefaultFocusTraversalKeys<T1>(int id, Set<T1> keystrokes) where T1 : AWTKeyStroke
		{
			if (id < 0 || id >= TRAVERSAL_KEY_LENGTH)
			{
				throw new IllegalArgumentException("invalid focus traversal key identifier");
			}
			if (keystrokes == null)
			{
				throw new IllegalArgumentException("cannot set null Set of default focus traversal keys");
			}

			Set<AWTKeyStroke> oldKeys;

			lock (this)
			{
				foreach (AWTKeyStroke keystroke in keystrokes)
				{

					if (keystroke == null)
					{
						throw new IllegalArgumentException("cannot set null focus traversal key");
					}

					if (keystroke.KeyChar != KeyEvent.CHAR_UNDEFINED)
					{
						throw new IllegalArgumentException("focus traversal keys cannot map to KEY_TYPED events");
					}

					// Check to see if key already maps to another traversal
					// operation
					for (int i = 0; i < TRAVERSAL_KEY_LENGTH; i++)
					{
						if (i == id)
						{
							continue;
						}

						if (DefaultFocusTraversalKeys[i].Contains(keystroke))
						{
							throw new IllegalArgumentException("focus traversal keys must be unique for a Component");
						}
					}
				}

				oldKeys = DefaultFocusTraversalKeys[id];
				DefaultFocusTraversalKeys[id] = Collections.UnmodifiableSet(new HashSet<>(keystrokes));
			}

			FirePropertyChange(DefaultFocusTraversalKeyPropertyNames[id], oldKeys, keystrokes);
		}

		/// <summary>
		/// Returns a Set of default focus traversal keys for a given traversal
		/// operation. This traversal key Set will be in effect on all Windows that
		/// have no such Set of their own explicitly defined. This Set will also be
		/// inherited, recursively, by any child Component of those Windows that has
		/// no such Set of its own explicitly defined. (See
		/// <code>setDefaultFocusTraversalKeys</code> for a full description of each
		/// operation.)
		/// </summary>
		/// <param name="id"> one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
		///        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
		///        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
		///        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS </param>
		/// <returns> the <code>Set</code> of <code>AWTKeyStroke</code>s
		///         for the specified operation; the <code>Set</code>
		///         will be unmodifiable, and may be empty; <code>null</code>
		///         will never be returned </returns>
		/// <seealso cref= #setDefaultFocusTraversalKeys </seealso>
		/// <seealso cref= Component#setFocusTraversalKeys </seealso>
		/// <seealso cref= Component#getFocusTraversalKeys </seealso>
		/// <exception cref="IllegalArgumentException"> if id is not one of
		///         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
		///         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
		///         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
		///         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS </exception>
		public virtual Set<AWTKeyStroke> GetDefaultFocusTraversalKeys(int id)
		{
			if (id < 0 || id >= TRAVERSAL_KEY_LENGTH)
			{
				throw new IllegalArgumentException("invalid focus traversal key identifier");
			}

			// Okay to return Set directly because it is an unmodifiable view
			return DefaultFocusTraversalKeys[id];
		}

		/// <summary>
		/// Returns the current focus cycle root, if the current focus cycle root is
		/// in the same context as the calling thread. If the focus owner is itself
		/// a focus cycle root, then it may be ambiguous as to which Components
		/// represent the next and previous Components to focus during normal focus
		/// traversal. In that case, the current focus cycle root is used to
		/// differentiate among the possibilities.
		/// <para>
		/// This method is intended to be used only by KeyboardFocusManagers and
		/// focus implementations. It is not for general client use.
		/// 
		/// </para>
		/// </summary>
		/// <returns> the current focus cycle root, or null if the current focus cycle
		///         root is not a member of the calling thread's context </returns>
		/// <seealso cref= #getGlobalCurrentFocusCycleRoot </seealso>
		/// <seealso cref= #setGlobalCurrentFocusCycleRoot </seealso>
		public virtual Container CurrentFocusCycleRoot
		{
			get
			{
				lock (typeof(KeyboardFocusManager))
				{
					if (CurrentFocusCycleRoot_Renamed == null)
					{
						return null;
					}
    
					return (CurrentFocusCycleRoot_Renamed.AppContext == AppContext.AppContext) ? CurrentFocusCycleRoot_Renamed : null;
				}
			}
		}

		/// <summary>
		/// Returns the current focus cycle root, even if the calling thread is in a
		/// different context than the current focus cycle root. If the focus owner
		/// is itself a focus cycle root, then it may be ambiguous as to which
		/// Components represent the next and previous Components to focus during
		/// normal focus traversal. In that case, the current focus cycle root is
		/// used to differentiate among the possibilities.
		/// </summary>
		/// <returns> the current focus cycle root, or null if the current focus cycle
		///         root is not a member of the calling thread's context </returns>
		/// <seealso cref= #getCurrentFocusCycleRoot </seealso>
		/// <seealso cref= #setGlobalCurrentFocusCycleRoot </seealso>
		/// <exception cref="SecurityException"> if this KeyboardFocusManager is not the
		///         current KeyboardFocusManager for the calling thread's context
		///         and if the calling thread does not have "replaceKeyboardFocusManager"
		///         permission </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: protected Container getGlobalCurrentFocusCycleRoot() throws SecurityException
		protected internal virtual Container GlobalCurrentFocusCycleRoot
		{
			get
			{
				lock (typeof(KeyboardFocusManager))
				{
					CheckKFMSecurity();
					return CurrentFocusCycleRoot_Renamed;
				}
			}
			set
			{
				CheckReplaceKFMPermission();
    
				Container oldFocusCycleRoot;
    
				lock (typeof(KeyboardFocusManager))
				{
					oldFocusCycleRoot = CurrentFocusCycleRoot;
					CurrentFocusCycleRoot_Renamed = value;
				}
    
				FirePropertyChange("currentFocusCycleRoot", oldFocusCycleRoot, value);
			}
		}


//JAVA TO C# CONVERTER WARNING: 'final' parameters are not allowed in .NET:
//ORIGINAL LINE: void setGlobalCurrentFocusCycleRootPriv(final Container newFocusCycleRoot)
		internal virtual Container GlobalCurrentFocusCycleRootPriv
		{
			set
			{
				AccessController.doPrivileged(new PrivilegedActionAnonymousInnerClassHelper2(this, value));
			}
		}

		private class PrivilegedActionAnonymousInnerClassHelper2 : PrivilegedAction<Void>
		{
			private readonly KeyboardFocusManager OuterInstance;

			private java.awt.Container NewFocusCycleRoot;

			public PrivilegedActionAnonymousInnerClassHelper2(KeyboardFocusManager outerInstance, java.awt.Container newFocusCycleRoot)
			{
				this.OuterInstance = outerInstance;
				this.NewFocusCycleRoot = newFocusCycleRoot;
			}

			public virtual Void Run()
			{
				outerInstance.GlobalCurrentFocusCycleRoot = NewFocusCycleRoot;
				return null;
			}
		}

		/// <summary>
		/// Adds a PropertyChangeListener to the listener list. The listener is
		/// registered for all bound properties of this class, including the
		/// following:
		/// <ul>
		///    <li>whether the KeyboardFocusManager is currently managing focus
		///        for this application or applet's browser context
		///        ("managingFocus")</li>
		///    <li>the focus owner ("focusOwner")</li>
		///    <li>the permanent focus owner ("permanentFocusOwner")</li>
		///    <li>the focused Window ("focusedWindow")</li>
		///    <li>the active Window ("activeWindow")</li>
		///    <li>the default focus traversal policy
		///        ("defaultFocusTraversalPolicy")</li>
		///    <li>the Set of default FORWARD_TRAVERSAL_KEYS
		///        ("forwardDefaultFocusTraversalKeys")</li>
		///    <li>the Set of default BACKWARD_TRAVERSAL_KEYS
		///        ("backwardDefaultFocusTraversalKeys")</li>
		///    <li>the Set of default UP_CYCLE_TRAVERSAL_KEYS
		///        ("upCycleDefaultFocusTraversalKeys")</li>
		///    <li>the Set of default DOWN_CYCLE_TRAVERSAL_KEYS
		///        ("downCycleDefaultFocusTraversalKeys")</li>
		///    <li>the current focus cycle root ("currentFocusCycleRoot")</li>
		/// </ul>
		/// If listener is null, no exception is thrown and no action is performed.
		/// </summary>
		/// <param name="listener"> the PropertyChangeListener to be added </param>
		/// <seealso cref= #removePropertyChangeListener </seealso>
		/// <seealso cref= #getPropertyChangeListeners </seealso>
		/// <seealso cref= #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener) </seealso>
		public virtual void AddPropertyChangeListener(PropertyChangeListener listener)
		{
			if (listener != null)
			{
				lock (this)
				{
					if (ChangeSupport == null)
					{
						ChangeSupport = new PropertyChangeSupport(this);
					}
					ChangeSupport.AddPropertyChangeListener(listener);
				}
			}
		}

		/// <summary>
		/// Removes a PropertyChangeListener from the listener list. This method
		/// should be used to remove the PropertyChangeListeners that were
		/// registered for all bound properties of this class.
		/// <para>
		/// If listener is null, no exception is thrown and no action is performed.
		/// 
		/// </para>
		/// </summary>
		/// <param name="listener"> the PropertyChangeListener to be removed </param>
		/// <seealso cref= #addPropertyChangeListener </seealso>
		/// <seealso cref= #getPropertyChangeListeners </seealso>
		/// <seealso cref= #removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener) </seealso>
		public virtual void RemovePropertyChangeListener(PropertyChangeListener listener)
		{
			if (listener != null)
			{
				lock (this)
				{
					if (ChangeSupport != null)
					{
						ChangeSupport.RemovePropertyChangeListener(listener);
					}
				}
			}
		}

		/// <summary>
		/// Returns an array of all the property change listeners
		/// registered on this keyboard focus manager.
		/// </summary>
		/// <returns> all of this keyboard focus manager's
		///         <code>PropertyChangeListener</code>s
		///         or an empty array if no property change
		///         listeners are currently registered
		/// </returns>
		/// <seealso cref= #addPropertyChangeListener </seealso>
		/// <seealso cref= #removePropertyChangeListener </seealso>
		/// <seealso cref= #getPropertyChangeListeners(java.lang.String)
		/// @since 1.4 </seealso>
		public virtual PropertyChangeListener[] PropertyChangeListeners
		{
			get
			{
				lock (this)
				{
					if (ChangeSupport == null)
					{
						ChangeSupport = new PropertyChangeSupport(this);
					}
					return ChangeSupport.PropertyChangeListeners;
				}
			}
		}

		/// <summary>
		/// Adds a PropertyChangeListener to the listener list for a specific
		/// property. The specified property may be user-defined, or one of the
		/// following:
		/// <ul>
		///    <li>whether the KeyboardFocusManager is currently managing focus
		///        for this application or applet's browser context
		///        ("managingFocus")</li>
		///    <li>the focus owner ("focusOwner")</li>
		///    <li>the permanent focus owner ("permanentFocusOwner")</li>
		///    <li>the focused Window ("focusedWindow")</li>
		///    <li>the active Window ("activeWindow")</li>
		///    <li>the default focus traversal policy
		///        ("defaultFocusTraversalPolicy")</li>
		///    <li>the Set of default FORWARD_TRAVERSAL_KEYS
		///        ("forwardDefaultFocusTraversalKeys")</li>
		///    <li>the Set of default BACKWARD_TRAVERSAL_KEYS
		///        ("backwardDefaultFocusTraversalKeys")</li>
		///    <li>the Set of default UP_CYCLE_TRAVERSAL_KEYS
		///        ("upCycleDefaultFocusTraversalKeys")</li>
		///    <li>the Set of default DOWN_CYCLE_TRAVERSAL_KEYS
		///        ("downCycleDefaultFocusTraversalKeys")</li>
		///    <li>the current focus cycle root ("currentFocusCycleRoot")</li>
		/// </ul>
		/// If listener is null, no exception is thrown and no action is performed.
		/// </summary>
		/// <param name="propertyName"> one of the property names listed above </param>
		/// <param name="listener"> the PropertyChangeListener to be added </param>
		/// <seealso cref= #addPropertyChangeListener(java.beans.PropertyChangeListener) </seealso>
		/// <seealso cref= #removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener) </seealso>
		/// <seealso cref= #getPropertyChangeListeners(java.lang.String) </seealso>
		public virtual void AddPropertyChangeListener(String propertyName, PropertyChangeListener listener)
		{
			if (listener != null)
			{
				lock (this)
				{
					if (ChangeSupport == null)
					{
						ChangeSupport = new PropertyChangeSupport(this);
					}
					ChangeSupport.AddPropertyChangeListener(propertyName, listener);
				}
			}
		}

		/// <summary>
		/// Removes a PropertyChangeListener from the listener list for a specific
		/// property. This method should be used to remove PropertyChangeListeners
		/// that were registered for a specific bound property.
		/// <para>
		/// If listener is null, no exception is thrown and no action is performed.
		/// 
		/// </para>
		/// </summary>
		/// <param name="propertyName"> a valid property name </param>
		/// <param name="listener"> the PropertyChangeListener to be removed </param>
		/// <seealso cref= #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener) </seealso>
		/// <seealso cref= #getPropertyChangeListeners(java.lang.String) </seealso>
		/// <seealso cref= #removePropertyChangeListener(java.beans.PropertyChangeListener) </seealso>
		public virtual void RemovePropertyChangeListener(String propertyName, PropertyChangeListener listener)
		{
			if (listener != null)
			{
				lock (this)
				{
					if (ChangeSupport != null)
					{
						ChangeSupport.RemovePropertyChangeListener(propertyName, listener);
					}
				}
			}
		}

		/// <summary>
		/// Returns an array of all the <code>PropertyChangeListener</code>s
		/// associated with the named property.
		/// </summary>
		/// <returns> all of the <code>PropertyChangeListener</code>s associated with
		///         the named property or an empty array if no such listeners have
		///         been added.
		/// </returns>
		/// <seealso cref= #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener) </seealso>
		/// <seealso cref= #removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)
		/// @since 1.4 </seealso>
		public virtual PropertyChangeListener[] GetPropertyChangeListeners(String propertyName)
		{
			lock (this)
			{
				if (ChangeSupport == null)
				{
					ChangeSupport = new PropertyChangeSupport(this);
				}
				return ChangeSupport.GetPropertyChangeListeners(propertyName);
			}
		}

		/// <summary>
		/// Fires a PropertyChangeEvent in response to a change in a bound property.
		/// The event will be delivered to all registered PropertyChangeListeners.
		/// No event will be delivered if oldValue and newValue are the same.
		/// </summary>
		/// <param name="propertyName"> the name of the property that has changed </param>
		/// <param name="oldValue"> the property's previous value </param>
		/// <param name="newValue"> the property's new value </param>
		protected internal virtual void FirePropertyChange(String propertyName, Object oldValue, Object newValue)
		{
			if (oldValue == newValue)
			{
				return;
			}
			PropertyChangeSupport changeSupport = this.ChangeSupport;
			if (changeSupport != null)
			{
				changeSupport.FirePropertyChange(propertyName, oldValue, newValue);
			}
		}

		/// <summary>
		/// Adds a VetoableChangeListener to the listener list. The listener is
		/// registered for all vetoable properties of this class, including the
		/// following:
		/// <ul>
		///    <li>the focus owner ("focusOwner")</li>
		///    <li>the permanent focus owner ("permanentFocusOwner")</li>
		///    <li>the focused Window ("focusedWindow")</li>
		///    <li>the active Window ("activeWindow")</li>
		/// </ul>
		/// If listener is null, no exception is thrown and no action is performed.
		/// </summary>
		/// <param name="listener"> the VetoableChangeListener to be added </param>
		/// <seealso cref= #removeVetoableChangeListener </seealso>
		/// <seealso cref= #getVetoableChangeListeners </seealso>
		/// <seealso cref= #addVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener) </seealso>
		public virtual void AddVetoableChangeListener(VetoableChangeListener listener)
		{
			if (listener != null)
			{
				lock (this)
				{
					if (VetoableSupport == null)
					{
						VetoableSupport = new VetoableChangeSupport(this);
					}
					VetoableSupport.AddVetoableChangeListener(listener);
				}
			}
		}

		/// <summary>
		/// Removes a VetoableChangeListener from the listener list. This method
		/// should be used to remove the VetoableChangeListeners that were
		/// registered for all vetoable properties of this class.
		/// <para>
		/// If listener is null, no exception is thrown and no action is performed.
		/// 
		/// </para>
		/// </summary>
		/// <param name="listener"> the VetoableChangeListener to be removed </param>
		/// <seealso cref= #addVetoableChangeListener </seealso>
		/// <seealso cref= #getVetoableChangeListeners </seealso>
		/// <seealso cref= #removeVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener) </seealso>
		public virtual void RemoveVetoableChangeListener(VetoableChangeListener listener)
		{
			if (listener != null)
			{
				lock (this)
				{
					if (VetoableSupport != null)
					{
						VetoableSupport.RemoveVetoableChangeListener(listener);
					}
				}
			}
		}

		/// <summary>
		/// Returns an array of all the vetoable change listeners
		/// registered on this keyboard focus manager.
		/// </summary>
		/// <returns> all of this keyboard focus manager's
		///         <code>VetoableChangeListener</code>s
		///         or an empty array if no vetoable change
		///         listeners are currently registered
		/// </returns>
		/// <seealso cref= #addVetoableChangeListener </seealso>
		/// <seealso cref= #removeVetoableChangeListener </seealso>
		/// <seealso cref= #getVetoableChangeListeners(java.lang.String)
		/// @since 1.4 </seealso>
		public virtual VetoableChangeListener[] VetoableChangeListeners
		{
			get
			{
				lock (this)
				{
					if (VetoableSupport == null)
					{
						VetoableSupport = new VetoableChangeSupport(this);
					}
					return VetoableSupport.VetoableChangeListeners;
				}
			}
		}

		/// <summary>
		/// Adds a VetoableChangeListener to the listener list for a specific
		/// property. The specified property may be user-defined, or one of the
		/// following:
		/// <ul>
		///    <li>the focus owner ("focusOwner")</li>
		///    <li>the permanent focus owner ("permanentFocusOwner")</li>
		///    <li>the focused Window ("focusedWindow")</li>
		///    <li>the active Window ("activeWindow")</li>
		/// </ul>
		/// If listener is null, no exception is thrown and no action is performed.
		/// </summary>
		/// <param name="propertyName"> one of the property names listed above </param>
		/// <param name="listener"> the VetoableChangeListener to be added </param>
		/// <seealso cref= #addVetoableChangeListener(java.beans.VetoableChangeListener) </seealso>
		/// <seealso cref= #removeVetoableChangeListener </seealso>
		/// <seealso cref= #getVetoableChangeListeners </seealso>
		public virtual void AddVetoableChangeListener(String propertyName, VetoableChangeListener listener)
		{
			if (listener != null)
			{
				lock (this)
				{
					if (VetoableSupport == null)
					{
						VetoableSupport = new VetoableChangeSupport(this);
					}
					VetoableSupport.AddVetoableChangeListener(propertyName, listener);
				}
			}
		}

		/// <summary>
		/// Removes a VetoableChangeListener from the listener list for a specific
		/// property. This method should be used to remove VetoableChangeListeners
		/// that were registered for a specific bound property.
		/// <para>
		/// If listener is null, no exception is thrown and no action is performed.
		/// 
		/// </para>
		/// </summary>
		/// <param name="propertyName"> a valid property name </param>
		/// <param name="listener"> the VetoableChangeListener to be removed </param>
		/// <seealso cref= #addVetoableChangeListener </seealso>
		/// <seealso cref= #getVetoableChangeListeners </seealso>
		/// <seealso cref= #removeVetoableChangeListener(java.beans.VetoableChangeListener) </seealso>
		public virtual void RemoveVetoableChangeListener(String propertyName, VetoableChangeListener listener)
		{
			if (listener != null)
			{
				lock (this)
				{
					if (VetoableSupport != null)
					{
						VetoableSupport.RemoveVetoableChangeListener(propertyName, listener);
					}
				}
			}
		}

		/// <summary>
		/// Returns an array of all the <code>VetoableChangeListener</code>s
		/// associated with the named property.
		/// </summary>
		/// <returns> all of the <code>VetoableChangeListener</code>s associated with
		///         the named property or an empty array if no such listeners have
		///         been added.
		/// </returns>
		/// <seealso cref= #addVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener) </seealso>
		/// <seealso cref= #removeVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener) </seealso>
		/// <seealso cref= #getVetoableChangeListeners
		/// @since 1.4 </seealso>
		public virtual VetoableChangeListener[] GetVetoableChangeListeners(String propertyName)
		{
			lock (this)
			{
				if (VetoableSupport == null)
				{
					VetoableSupport = new VetoableChangeSupport(this);
				}
				return VetoableSupport.GetVetoableChangeListeners(propertyName);
			}
		}

		/// <summary>
		/// Fires a PropertyChangeEvent in response to a change in a vetoable
		/// property. The event will be delivered to all registered
		/// VetoableChangeListeners. If a VetoableChangeListener throws a
		/// PropertyVetoException, a new event is fired reverting all
		/// VetoableChangeListeners to the old value and the exception is then
		/// rethrown. No event will be delivered if oldValue and newValue are the
		/// same.
		/// </summary>
		/// <param name="propertyName"> the name of the property that has changed </param>
		/// <param name="oldValue"> the property's previous value </param>
		/// <param name="newValue"> the property's new value </param>
		/// <exception cref="java.beans.PropertyVetoException"> if a
		///         <code>VetoableChangeListener</code> threw
		///         <code>PropertyVetoException</code> </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: protected void fireVetoableChange(String propertyName, Object oldValue, Object newValue) throws java.beans.PropertyVetoException
		protected internal virtual void FireVetoableChange(String propertyName, Object oldValue, Object newValue)
		{
			if (oldValue == newValue)
			{
				return;
			}
			VetoableChangeSupport vetoableSupport = this.VetoableSupport;
			if (vetoableSupport != null)
			{
				vetoableSupport.FireVetoableChange(propertyName, oldValue, newValue);
			}
		}

		/// <summary>
		/// Adds a KeyEventDispatcher to this KeyboardFocusManager's dispatcher
		/// chain. This KeyboardFocusManager will request that each
		/// KeyEventDispatcher dispatch KeyEvents generated by the user before
		/// finally dispatching the KeyEvent itself. KeyEventDispatchers will be
		/// notified in the order in which they were added. Notifications will halt
		/// as soon as one KeyEventDispatcher returns <code>true</code> from its
		/// <code>dispatchKeyEvent</code> method. There is no limit to the total
		/// number of KeyEventDispatchers which can be added, nor to the number of
		/// times which a particular KeyEventDispatcher instance can be added.
		/// <para>
		/// If a null dispatcher is specified, no action is taken and no exception
		/// is thrown.
		/// </para>
		/// <para>
		/// In a multithreaded application, <seealso cref="KeyEventDispatcher"/> behaves
		/// the same as other AWT listeners.  See
		/// <a href="doc-files/AWTThreadIssues.html#ListenersThreads"
		/// >AWT Threading Issues</a> for more details.
		/// 
		/// </para>
		/// </summary>
		/// <param name="dispatcher"> the KeyEventDispatcher to add to the dispatcher chain </param>
		/// <seealso cref= #removeKeyEventDispatcher </seealso>
		public virtual void AddKeyEventDispatcher(KeyEventDispatcher dispatcher)
		{
			if (dispatcher != null)
			{
				lock (this)
				{
					if (KeyEventDispatchers_Renamed == null)
					{
						KeyEventDispatchers_Renamed = new LinkedList<>();
					}
					KeyEventDispatchers_Renamed.AddLast(dispatcher);
				}
			}
		}

		/// <summary>
		/// Removes a KeyEventDispatcher which was previously added to this
		/// KeyboardFocusManager's dispatcher chain. This KeyboardFocusManager
		/// cannot itself be removed, unless it was explicitly re-registered via a
		/// call to <code>addKeyEventDispatcher</code>.
		/// <para>
		/// If a null dispatcher is specified, if the specified dispatcher is not
		/// in the dispatcher chain, or if this KeyboardFocusManager is specified
		/// without having been explicitly re-registered, no action is taken and no
		/// exception is thrown.
		/// </para>
		/// <para>
		/// In a multithreaded application, <seealso cref="KeyEventDispatcher"/> behaves
		/// the same as other AWT listeners.  See
		/// <a href="doc-files/AWTThreadIssues.html#ListenersThreads"
		/// >AWT Threading Issues</a> for more details.
		/// 
		/// </para>
		/// </summary>
		/// <param name="dispatcher"> the KeyEventDispatcher to remove from the dispatcher
		///        chain </param>
		/// <seealso cref= #addKeyEventDispatcher </seealso>
		public virtual void RemoveKeyEventDispatcher(KeyEventDispatcher dispatcher)
		{
			if (dispatcher != null)
			{
				lock (this)
				{
					if (KeyEventDispatchers_Renamed != null)
					{
//JAVA TO C# CONVERTER TODO TASK: There is no .NET LinkedList equivalent to the Java 'remove' method:
						KeyEventDispatchers_Renamed.remove(dispatcher);
					}
				}
			}
		}

		/// <summary>
		/// Returns this KeyboardFocusManager's KeyEventDispatcher chain as a List.
		/// The List will not include this KeyboardFocusManager unless it was
		/// explicitly re-registered via a call to
		/// <code>addKeyEventDispatcher</code>. If no other KeyEventDispatchers are
		/// registered, implementations are free to return null or a List of length
		/// 0. Client code should not assume one behavior over another, nor should
		/// it assume that the behavior, once established, will not change.
		/// </summary>
		/// <returns> a possibly null or empty List of KeyEventDispatchers </returns>
		/// <seealso cref= #addKeyEventDispatcher </seealso>
		/// <seealso cref= #removeKeyEventDispatcher </seealso>
		protected internal virtual IList<KeyEventDispatcher> KeyEventDispatchers
		{
			get
			{
				lock (this)
				{
					return (KeyEventDispatchers_Renamed != null) ? (IList)KeyEventDispatchers_Renamed.clone() : null;
				}
			}
		}

		/// <summary>
		/// Adds a KeyEventPostProcessor to this KeyboardFocusManager's post-
		/// processor chain. After a KeyEvent has been dispatched to and handled by
		/// its target, KeyboardFocusManager will request that each
		/// KeyEventPostProcessor perform any necessary post-processing as part
		/// of the KeyEvent's final resolution. KeyEventPostProcessors
		/// will be notified in the order in which they were added; the current
		/// KeyboardFocusManager will be notified last. Notifications will halt
		/// as soon as one KeyEventPostProcessor returns <code>true</code> from its
		/// <code>postProcessKeyEvent</code> method. There is no limit to the the
		/// total number of KeyEventPostProcessors that can be added, nor to the
		/// number of times that a particular KeyEventPostProcessor instance can be
		/// added.
		/// <para>
		/// If a null post-processor is specified, no action is taken and no
		/// exception is thrown.
		/// </para>
		/// <para>
		/// In a multithreaded application, <seealso cref="KeyEventPostProcessor"/> behaves
		/// the same as other AWT listeners.  See
		/// <a href="doc-files/AWTThreadIssues.html#ListenersThreads"
		/// >AWT Threading Issues</a> for more details.
		/// 
		/// </para>
		/// </summary>
		/// <param name="processor"> the KeyEventPostProcessor to add to the post-processor
		///        chain </param>
		/// <seealso cref= #removeKeyEventPostProcessor </seealso>
		public virtual void AddKeyEventPostProcessor(KeyEventPostProcessor processor)
		{
			if (processor != null)
			{
				lock (this)
				{
					if (KeyEventPostProcessors_Renamed == null)
					{
						KeyEventPostProcessors_Renamed = new LinkedList<>();
					}
					KeyEventPostProcessors_Renamed.AddLast(processor);
				}
			}
		}


		/// <summary>
		/// Removes a previously added KeyEventPostProcessor from this
		/// KeyboardFocusManager's post-processor chain. This KeyboardFocusManager
		/// cannot itself be entirely removed from the chain. Only additional
		/// references added via <code>addKeyEventPostProcessor</code> can be
		/// removed.
		/// <para>
		/// If a null post-processor is specified, if the specified post-processor
		/// is not in the post-processor chain, or if this KeyboardFocusManager is
		/// specified without having been explicitly added, no action is taken and
		/// no exception is thrown.
		/// </para>
		/// <para>
		/// In a multithreaded application, <seealso cref="KeyEventPostProcessor"/> behaves
		/// the same as other AWT listeners.  See
		/// <a href="doc-files/AWTThreadIssues.html#ListenersThreads"
		/// >AWT Threading Issues</a> for more details.
		/// 
		/// </para>
		/// </summary>
		/// <param name="processor"> the KeyEventPostProcessor to remove from the post-
		///        processor chain </param>
		/// <seealso cref= #addKeyEventPostProcessor </seealso>
		public virtual void RemoveKeyEventPostProcessor(KeyEventPostProcessor processor)
		{
			if (processor != null)
			{
				lock (this)
				{
					if (KeyEventPostProcessors_Renamed != null)
					{
//JAVA TO C# CONVERTER TODO TASK: There is no .NET LinkedList equivalent to the Java 'remove' method:
						KeyEventPostProcessors_Renamed.remove(processor);
					}
				}
			}
		}


		/// <summary>
		/// Returns this KeyboardFocusManager's KeyEventPostProcessor chain as a
		/// List. The List will not include this KeyboardFocusManager unless it was
		/// explicitly added via a call to <code>addKeyEventPostProcessor</code>. If
		/// no KeyEventPostProcessors are registered, implementations are free to
		/// return null or a List of length 0. Client code should not assume one
		/// behavior over another, nor should it assume that the behavior, once
		/// established, will not change.
		/// </summary>
		/// <returns> a possibly null or empty List of KeyEventPostProcessors </returns>
		/// <seealso cref= #addKeyEventPostProcessor </seealso>
		/// <seealso cref= #removeKeyEventPostProcessor </seealso>
		protected internal virtual IList<KeyEventPostProcessor> KeyEventPostProcessors
		{
			get
			{
				return (KeyEventPostProcessors_Renamed != null) ? (IList)KeyEventPostProcessors_Renamed.clone() : null;
			}
		}



		internal static Component MostRecentFocusOwner
		{
			set
			{
				Component window = value;
				while (window != null && !(window is Window))
				{
					window = window.Parent_Renamed;
				}
				if (window != null)
				{
					SetMostRecentFocusOwner((Window)window, value);
				}
			}
		}
		internal static void SetMostRecentFocusOwner(Window window, Component component)
		{
			lock (typeof(KeyboardFocusManager))
			{
				// ATTN: component has a strong reference to window via chain
				// of Component.parent fields.  Since WeakHasMap refers to its
				// values strongly, we need to break the strong link from the
				// value (component) back to its key (window).
				WeakReference<Component> weakValue = null;
				if (component != null)
				{
					weakValue = new WeakReference<>(component);
				}
				MostRecentFocusOwners[window] = weakValue;
			}
		}
		internal static void ClearMostRecentFocusOwner(Component comp)
		{
			Container window;

			if (comp == null)
			{
				return;
			}

			lock (comp.TreeLock)
			{
				window = comp.Parent;
				while (window != null && !(window is Window))
				{
					window = window.Parent;
				}
			}

			lock (typeof(KeyboardFocusManager))
			{
				if ((window != null) && (GetMostRecentFocusOwner((Window)window) == comp))
				{
					SetMostRecentFocusOwner((Window)window, null);
				}
				// Also clear temporary lost component stored in Window
				if (window != null)
				{
					Window realWindow = (Window)window;
					if (realWindow.TemporaryLostComponent == comp)
					{
						realWindow.TemporaryLostComponent = null;
					}
				}
			}
		}

		/*
		 * Please be careful changing this method! It is called from
		 * javax.swing.JComponent.runInputVerifier() using reflection.
		 */
		internal static Component GetMostRecentFocusOwner(Window window)
		{
			lock (typeof(KeyboardFocusManager))
			{
				WeakReference<Component> weakValue = (WeakReference)MostRecentFocusOwners[window];
				return weakValue == null ? null : (Component)weakValue.get();
			}
		}

		/// <summary>
		/// This method is called by the AWT event dispatcher requesting that the
		/// current KeyboardFocusManager dispatch the specified event on its behalf.
		/// It is expected that all KeyboardFocusManagers will dispatch all
		/// FocusEvents, all WindowEvents related to focus, and all KeyEvents.
		/// These events should be dispatched based on the KeyboardFocusManager's
		/// notion of the focus owner and the focused and active Windows, sometimes
		/// overriding the source of the specified AWTEvent. Dispatching must be
		/// done using <code>redispatchEvent</code> to prevent the AWT event
		/// dispatcher from recursively requesting that the KeyboardFocusManager
		/// dispatch the event again. If this method returns <code>false</code>,
		/// then the AWT event dispatcher will attempt to dispatch the event itself.
		/// </summary>
		/// <param name="e"> the AWTEvent to be dispatched </param>
		/// <returns> <code>true</code> if this method dispatched the event;
		///         <code>false</code> otherwise </returns>
		/// <seealso cref= #redispatchEvent </seealso>
		/// <seealso cref= #dispatchKeyEvent </seealso>
		public abstract bool DispatchEvent(AWTEvent e);

		/// <summary>
		/// Redispatches an AWTEvent in such a way that the AWT event dispatcher
		/// will not recursively request that the KeyboardFocusManager, or any
		/// installed KeyEventDispatchers, dispatch the event again. Client
		/// implementations of <code>dispatchEvent</code> and client-defined
		/// KeyEventDispatchers must call <code>redispatchEvent(target, e)</code>
		/// instead of <code>target.dispatchEvent(e)</code> to dispatch an event.
		/// <para>
		/// This method is intended to be used only by KeyboardFocusManagers and
		/// KeyEventDispatchers. It is not for general client use.
		/// 
		/// </para>
		/// </summary>
		/// <param name="target"> the Component to which the event should be dispatched </param>
		/// <param name="e"> the event to dispatch </param>
		/// <seealso cref= #dispatchEvent </seealso>
		/// <seealso cref= KeyEventDispatcher </seealso>
		public void RedispatchEvent(Component target, AWTEvent e)
		{
			e.FocusManagerIsDispatching = true;
			target.DispatchEvent(e);
			e.FocusManagerIsDispatching = false;
		}

		/// <summary>
		/// Typically this method will be called by <code>dispatchEvent</code> if no
		/// other KeyEventDispatcher in the dispatcher chain dispatched the
		/// KeyEvent, or if no other KeyEventDispatchers are registered. If an
		/// implementation of this method returns <code>false</code>,
		/// <code>dispatchEvent</code> may try to dispatch the KeyEvent itself, or
		/// may simply return <code>false</code>. If <code>true</code> is returned,
		/// <code>dispatchEvent</code> should return <code>true</code> as well.
		/// </summary>
		/// <param name="e"> the KeyEvent which the current KeyboardFocusManager has
		///        requested that this KeyEventDispatcher dispatch </param>
		/// <returns> <code>true</code> if the KeyEvent was dispatched;
		///         <code>false</code> otherwise </returns>
		/// <seealso cref= #dispatchEvent </seealso>
		public abstract bool DispatchKeyEvent(KeyEvent e);

		/// <summary>
		/// This method will be called by <code>dispatchKeyEvent</code>.
		/// By default, this method will handle any unconsumed KeyEvents that
		/// map to an AWT <code>MenuShortcut</code> by consuming the event
		/// and activating the shortcut.
		/// </summary>
		/// <param name="e"> the KeyEvent to post-process </param>
		/// <returns> <code>true</code> to indicate that no other
		///         KeyEventPostProcessor will be notified of the KeyEvent. </returns>
		/// <seealso cref= #dispatchKeyEvent </seealso>
		/// <seealso cref= MenuShortcut </seealso>
		public abstract bool PostProcessKeyEvent(KeyEvent e);

		/// <summary>
		/// This method initiates a focus traversal operation if and only if the
		/// KeyEvent represents a focus traversal key for the specified
		/// focusedComponent. It is expected that focusedComponent is the current
		/// focus owner, although this need not be the case. If it is not,
		/// focus traversal will nevertheless proceed as if focusedComponent
		/// were the current focus owner.
		/// </summary>
		/// <param name="focusedComponent"> the Component that will be the basis for a focus
		///        traversal operation if the specified event represents a focus
		///        traversal key for the Component </param>
		/// <param name="e"> the event that may represent a focus traversal key </param>
		public abstract void ProcessKeyEvent(Component focusedComponent, KeyEvent e);

		/// <summary>
		/// Called by the AWT to notify the KeyboardFocusManager that it should
		/// delay dispatching of KeyEvents until the specified Component becomes
		/// the focus owner. If client code requests a focus change, and the AWT
		/// determines that this request might be granted by the native windowing
		/// system, then the AWT will call this method. It is the responsibility of
		/// the KeyboardFocusManager to delay dispatching of KeyEvents with
		/// timestamps later than the specified time stamp until the specified
		/// Component receives a FOCUS_GAINED event, or the AWT cancels the delay
		/// request by invoking <code>dequeueKeyEvents</code> or
		/// <code>discardKeyEvents</code>.
		/// </summary>
		/// <param name="after"> timestamp of current event, or the current, system time if
		///        the current event has no timestamp, or the AWT cannot determine
		///        which event is currently being handled </param>
		/// <param name="untilFocused"> Component which should receive a FOCUS_GAINED event
		///        before any pending KeyEvents </param>
		/// <seealso cref= #dequeueKeyEvents </seealso>
		/// <seealso cref= #discardKeyEvents </seealso>
		protected internal abstract void EnqueueKeyEvents(long after, Component untilFocused);

		/// <summary>
		/// Called by the AWT to notify the KeyboardFocusManager that it should
		/// cancel delayed dispatching of KeyEvents. All KeyEvents which were
		/// enqueued because of a call to <code>enqueueKeyEvents</code> with the
		/// same timestamp and Component should be released for normal dispatching
		/// to the current focus owner. If the given timestamp is less than zero,
		/// the outstanding enqueue request for the given Component with the <b>
		/// oldest</b> timestamp (if any) should be cancelled.
		/// </summary>
		/// <param name="after"> the timestamp specified in the call to
		///        <code>enqueueKeyEvents</code>, or any value &lt; 0 </param>
		/// <param name="untilFocused"> the Component specified in the call to
		///        <code>enqueueKeyEvents</code> </param>
		/// <seealso cref= #enqueueKeyEvents </seealso>
		/// <seealso cref= #discardKeyEvents </seealso>
		protected internal abstract void DequeueKeyEvents(long after, Component untilFocused);

		/// <summary>
		/// Called by the AWT to notify the KeyboardFocusManager that it should
		/// cancel delayed dispatching of KeyEvents. All KeyEvents which were
		/// enqueued because of one or more calls to <code>enqueueKeyEvents</code>
		/// with the same Component should be discarded.
		/// </summary>
		/// <param name="comp"> the Component specified in one or more calls to
		///        <code>enqueueKeyEvents</code> </param>
		/// <seealso cref= #enqueueKeyEvents </seealso>
		/// <seealso cref= #dequeueKeyEvents </seealso>
		protected internal abstract void DiscardKeyEvents(Component comp);

		/// <summary>
		/// Focuses the Component after aComponent, typically based on a
		/// FocusTraversalPolicy.
		/// </summary>
		/// <param name="aComponent"> the Component that is the basis for the focus
		///        traversal operation </param>
		/// <seealso cref= FocusTraversalPolicy </seealso>
		public abstract void FocusNextComponent(Component aComponent);

		/// <summary>
		/// Focuses the Component before aComponent, typically based on a
		/// FocusTraversalPolicy.
		/// </summary>
		/// <param name="aComponent"> the Component that is the basis for the focus
		///        traversal operation </param>
		/// <seealso cref= FocusTraversalPolicy </seealso>
		public abstract void FocusPreviousComponent(Component aComponent);

		/// <summary>
		/// Moves the focus up one focus traversal cycle. Typically, the focus owner
		/// is set to aComponent's focus cycle root, and the current focus cycle
		/// root is set to the new focus owner's focus cycle root. If, however,
		/// aComponent's focus cycle root is a Window, then typically the focus
		/// owner is set to the Window's default Component to focus, and the current
		/// focus cycle root is unchanged.
		/// </summary>
		/// <param name="aComponent"> the Component that is the basis for the focus
		///        traversal operation </param>
		public abstract void UpFocusCycle(Component aComponent);

		/// <summary>
		/// Moves the focus down one focus traversal cycle. Typically, if
		/// aContainer is a focus cycle root, then the focus owner is set to
		/// aContainer's default Component to focus, and the current focus cycle
		/// root is set to aContainer. If aContainer is not a focus cycle root, then
		/// no focus traversal operation occurs.
		/// </summary>
		/// <param name="aContainer"> the Container that is the basis for the focus
		///        traversal operation </param>
		public abstract void DownFocusCycle(Container aContainer);

		/// <summary>
		/// Focuses the Component after the current focus owner.
		/// </summary>
		public void FocusNextComponent()
		{
			Component focusOwner = FocusOwner;
			if (focusOwner != null)
			{
				FocusNextComponent(focusOwner);
			}
		}

		/// <summary>
		/// Focuses the Component before the current focus owner.
		/// </summary>
		public void FocusPreviousComponent()
		{
			Component focusOwner = FocusOwner;
			if (focusOwner != null)
			{
				FocusPreviousComponent(focusOwner);
			}
		}

		/// <summary>
		/// Moves the focus up one focus traversal cycle from the current focus
		/// owner. Typically, the new focus owner is set to the current focus
		/// owner's focus cycle root, and the current focus cycle root is set to the
		/// new focus owner's focus cycle root. If, however, the current focus
		/// owner's focus cycle root is a Window, then typically the focus owner is
		/// set to the focus cycle root's default Component to focus, and the
		/// current focus cycle root is unchanged.
		/// </summary>
		public void UpFocusCycle()
		{
			Component focusOwner = FocusOwner;
			if (focusOwner != null)
			{
				UpFocusCycle(focusOwner);
			}
		}

		/// <summary>
		/// Moves the focus down one focus traversal cycle from the current focus
		/// owner, if and only if the current focus owner is a Container that is a
		/// focus cycle root. Typically, the focus owner is set to the current focus
		/// owner's default Component to focus, and the current focus cycle root is
		/// set to the current focus owner. If the current focus owner is not a
		/// Container that is a focus cycle root, then no focus traversal operation
		/// occurs.
		/// </summary>
		public void DownFocusCycle()
		{
			Component focusOwner = FocusOwner;
			if (focusOwner is Container)
			{
				DownFocusCycle((Container)focusOwner);
			}
		}

		/// <summary>
		/// Dumps the list of focus requests to stderr
		/// </summary>
		internal virtual void DumpRequests()
		{
			System.Console.Error.WriteLine(">>> Requests dump, time: " + DateTimeHelperClass.CurrentUnixTimeMillis());
			lock (HeavyweightRequests)
			{
				foreach (HeavyweightFocusRequest req in HeavyweightRequests)
				{
					System.Console.Error.WriteLine(">>> Req: " + req);
				}
			}
			System.Console.Error.WriteLine("");
		}

		private sealed class LightweightFocusRequest
		{
			internal readonly Component Component;
			internal readonly bool Temporary;
			internal readonly CausedFocusEvent.Cause Cause;

			internal LightweightFocusRequest(Component component, bool temporary, CausedFocusEvent.Cause cause)
			{
				this.Component = component;
				this.Temporary = temporary;
				this.Cause = cause;
			}
			public override String ToString()
			{
				return "LightweightFocusRequest[component=" + Component + ",temporary=" + Temporary + ", cause=" + Cause + "]";
			}
		}

		private sealed class HeavyweightFocusRequest
		{
			internal readonly Component Heavyweight;
			internal readonly LinkedList<LightweightFocusRequest> LightweightRequests;

			internal static readonly HeavyweightFocusRequest CLEAR_GLOBAL_FOCUS_OWNER = new HeavyweightFocusRequest();

			internal HeavyweightFocusRequest()
			{
				Heavyweight = null;
				LightweightRequests = null;
			}

			internal HeavyweightFocusRequest(Component heavyweight, Component descendant, bool temporary, CausedFocusEvent.Cause cause)
			{
				if (Log.isLoggable(PlatformLogger.Level.FINE))
				{
					if (heavyweight == null)
					{
						Log.fine("Assertion (heavyweight != null) failed");
					}
				}

				this.Heavyweight = heavyweight;
				this.LightweightRequests = new LinkedList<LightweightFocusRequest>();
				AddLightweightRequest(descendant, temporary, cause);
			}
			internal bool AddLightweightRequest(Component descendant, bool temporary, CausedFocusEvent.Cause cause)
			{
				if (Log.isLoggable(PlatformLogger.Level.FINE))
				{
					if (this == HeavyweightFocusRequest.CLEAR_GLOBAL_FOCUS_OWNER)
					{
						Log.fine("Assertion (this != HeavyweightFocusRequest.CLEAR_GLOBAL_FOCUS_OWNER) failed");
					}
					if (descendant == null)
					{
						Log.fine("Assertion (descendant != null) failed");
					}
				}

				Component lastDescendant = ((LightweightRequests.Count > 0) ? LightweightRequests.Last.Value.component : null);

				if (descendant != lastDescendant)
				{
					// Not a duplicate request
					LightweightRequests.AddLast(new LightweightFocusRequest(descendant, temporary, cause));
					return true;
				}
				else
				{
					return false;
				}
			}

			internal LightweightFocusRequest FirstLightweightRequest
			{
				get
				{
					if (this == CLEAR_GLOBAL_FOCUS_OWNER)
					{
						return null;
					}
					return LightweightRequests.First.Value;
				}
			}
			public override String ToString()
			{
				bool first = true;
				String str = "HeavyweightFocusRequest[heavweight=" + Heavyweight + ",lightweightRequests=";
				if (LightweightRequests == null)
				{
					str += null;
				}
				else
				{
					str += "[";

					foreach (LightweightFocusRequest lwRequest in LightweightRequests)
					{
						if (first)
						{
							first = false;
						}
						else
						{
							str += ",";
						}
						str += lwRequest;
					}
					str += "]";
				}
				str += "]";
				return str;
			}
		}

		/*
		 * heavyweightRequests is used as a monitor for synchronized changes of
		 * currentLightweightRequests, clearingCurrentLightweightRequests and
		 * newFocusOwner.
		 */
		private static LinkedList<HeavyweightFocusRequest> HeavyweightRequests = new LinkedList<HeavyweightFocusRequest>();
		private static LinkedList<LightweightFocusRequest> CurrentLightweightRequests;
		private static bool ClearingCurrentLightweightRequests;
		private static bool AllowSyncFocusRequests = true;
		private static Component NewFocusOwner = null;
		private static volatile bool DisableRestoreFocus;

		internal const int SNFH_FAILURE = 0;
		internal const int SNFH_SUCCESS_HANDLED = 1;
		internal const int SNFH_SUCCESS_PROCEED = 2;

		internal static bool ProcessSynchronousLightweightTransfer(Component heavyweight, Component descendant, bool temporary, bool focusedWindowChangeAllowed, long time)
		{
			Window parentWindow = SunToolkit.getContainingWindow(heavyweight);
			if (parentWindow == null || !parentWindow.SyncLWRequests)
			{
				return false;
			}
			if (descendant == null)
			{
				// Focus transfers from a lightweight child back to the
				// heavyweight Container should be treated like lightweight
				// focus transfers.
				descendant = heavyweight;
			}

			KeyboardFocusManager manager = GetCurrentKeyboardFocusManager(SunToolkit.targetToAppContext(descendant));

			FocusEvent currentFocusOwnerEvent = null;
			FocusEvent newFocusOwnerEvent = null;
			Component currentFocusOwner = manager.GlobalFocusOwner;

			lock (HeavyweightRequests)
			{
				HeavyweightFocusRequest hwFocusRequest = LastHWRequest;
				if (hwFocusRequest == null && heavyweight == manager.NativeFocusOwner && AllowSyncFocusRequests)
				{

					if (descendant == currentFocusOwner)
					{
						// Redundant request.
						return true;
					}

					// 'heavyweight' owns the native focus and there are no pending
					// requests. 'heavyweight' must be a Container and
					// 'descendant' must not be the focus owner. Otherwise,
					// we would never have gotten this far.
					manager.EnqueueKeyEvents(time, descendant);

					hwFocusRequest = new HeavyweightFocusRequest(heavyweight, descendant, temporary, CausedFocusEvent.Cause.UNKNOWN);
					HeavyweightRequests.AddLast(hwFocusRequest);

					if (currentFocusOwner != null)
					{
						currentFocusOwnerEvent = new FocusEvent(currentFocusOwner, FocusEvent.FOCUS_LOST, temporary, descendant);
					}
					newFocusOwnerEvent = new FocusEvent(descendant, FocusEvent.FOCUS_GAINED, temporary, currentFocusOwner);
				}
			}
			bool result = false;
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final boolean clearing = clearingCurrentLightweightRequests;
			bool clearing = ClearingCurrentLightweightRequests;

			Throwable caughtEx = null;
			try
			{
				ClearingCurrentLightweightRequests = false;
				lock (Component.LOCK)
				{

					if (currentFocusOwnerEvent != null && currentFocusOwner != null)
					{
						((AWTEvent) currentFocusOwnerEvent).IsPosted = true;
						caughtEx = DispatchAndCatchException(caughtEx, currentFocusOwner, currentFocusOwnerEvent);
						result = true;
					}

					if (newFocusOwnerEvent != null && descendant != null)
					{
						((AWTEvent) newFocusOwnerEvent).IsPosted = true;
						caughtEx = DispatchAndCatchException(caughtEx, descendant, newFocusOwnerEvent);
						result = true;
					}
				}
			}
			finally
			{
				ClearingCurrentLightweightRequests = clearing;
			}
			if (caughtEx is RuntimeException)
			{
				throw (RuntimeException)caughtEx;
			}
			else if (caughtEx is Error)
			{
				throw (Error)caughtEx;
			}
			return result;
		}

		/// <summary>
		/// Indicates whether the native implementation should proceed with a
		/// pending, native focus request. Before changing the focus at the native
		/// level, the AWT implementation should always call this function for
		/// permission. This function will reject the request if a duplicate request
		/// preceded it, or if the specified heavyweight Component already owns the
		/// focus and no native focus changes are pending. Otherwise, the request
		/// will be approved and the focus request list will be updated so that,
		/// if necessary, the proper descendant will be focused when the
		/// corresponding FOCUS_GAINED event on the heavyweight is received.
		/// 
		/// An implementation must ensure that calls to this method and native
		/// focus changes are atomic. If this is not guaranteed, then the ordering
		/// of the focus request list may be incorrect, leading to errors in the
		/// type-ahead mechanism. Typically this is accomplished by only calling
		/// this function from the native event pumping thread, or by holding a
		/// global, native lock during invocation.
		/// </summary>
		internal static int ShouldNativelyFocusHeavyweight(Component heavyweight, Component descendant, bool temporary, bool focusedWindowChangeAllowed, long time, CausedFocusEvent.Cause cause)
		{
			if (Log.isLoggable(PlatformLogger.Level.FINE))
			{
				if (heavyweight == null)
				{
					Log.fine("Assertion (heavyweight != null) failed");
				}
				if (time == 0)
				{
					Log.fine("Assertion (time != 0) failed");
				}
			}

			if (descendant == null)
			{
				// Focus transfers from a lightweight child back to the
				// heavyweight Container should be treated like lightweight
				// focus transfers.
				descendant = heavyweight;
			}

			KeyboardFocusManager manager = GetCurrentKeyboardFocusManager(SunToolkit.targetToAppContext(descendant));
			KeyboardFocusManager thisManager = CurrentKeyboardFocusManager;
			Component currentFocusOwner = thisManager.GlobalFocusOwner;
			Component nativeFocusOwner = thisManager.NativeFocusOwner;
			Window nativeFocusedWindow = thisManager.NativeFocusedWindow;
			if (FocusLog.isLoggable(PlatformLogger.Level.FINER))
			{
				FocusLog.finer("SNFH for {0} in {1}", Convert.ToString(descendant), Convert.ToString(heavyweight));
			}
			if (FocusLog.isLoggable(PlatformLogger.Level.FINEST))
			{
				FocusLog.finest("0. Current focus owner {0}", Convert.ToString(currentFocusOwner));
				FocusLog.finest("0. Native focus owner {0}", Convert.ToString(nativeFocusOwner));
				FocusLog.finest("0. Native focused window {0}", Convert.ToString(nativeFocusedWindow));
			}
			lock (HeavyweightRequests)
			{
				HeavyweightFocusRequest hwFocusRequest = LastHWRequest;
				if (FocusLog.isLoggable(PlatformLogger.Level.FINEST))
				{
					FocusLog.finest("Request {0}", Convert.ToString(hwFocusRequest));
				}
				if (hwFocusRequest == null && heavyweight == nativeFocusOwner && heavyweight.ContainingWindow == nativeFocusedWindow)
				{
					if (descendant == currentFocusOwner)
					{
						// Redundant request.
						if (FocusLog.isLoggable(PlatformLogger.Level.FINEST))
						{
							FocusLog.finest("1. SNFH_FAILURE for {0}", Convert.ToString(descendant));
						}
						return SNFH_FAILURE;
					}

					// 'heavyweight' owns the native focus and there are no pending
					// requests. 'heavyweight' must be a Container and
					// 'descendant' must not be the focus owner. Otherwise,
					// we would never have gotten this far.
					manager.EnqueueKeyEvents(time, descendant);

					hwFocusRequest = new HeavyweightFocusRequest(heavyweight, descendant, temporary, cause);
					HeavyweightRequests.AddLast(hwFocusRequest);

					if (currentFocusOwner != null)
					{
						FocusEvent currentFocusOwnerEvent = new CausedFocusEvent(currentFocusOwner, FocusEvent.FOCUS_LOST, temporary, descendant, cause);
						// Fix 5028014. Rolled out.
						// SunToolkit.postPriorityEvent(currentFocusOwnerEvent);
						SunToolkit.postEvent(currentFocusOwner.AppContext, currentFocusOwnerEvent);
					}
					FocusEvent newFocusOwnerEvent = new CausedFocusEvent(descendant, FocusEvent.FOCUS_GAINED, temporary, currentFocusOwner, cause);
					// Fix 5028014. Rolled out.
					// SunToolkit.postPriorityEvent(newFocusOwnerEvent);
					SunToolkit.postEvent(descendant.AppContext, newFocusOwnerEvent);

					if (FocusLog.isLoggable(PlatformLogger.Level.FINEST))
					{
						FocusLog.finest("2. SNFH_HANDLED for {0}", Convert.ToString(descendant));
					}
					return SNFH_SUCCESS_HANDLED;
				}
				else if (hwFocusRequest != null && hwFocusRequest.Heavyweight == heavyweight)
				{
					// 'heavyweight' doesn't have the native focus right now, but
					// if all pending requests were completed, it would. Add
					// descendant to the heavyweight's list of pending
					// lightweight focus transfers.
					if (hwFocusRequest.AddLightweightRequest(descendant, temporary, cause))
					{
						manager.EnqueueKeyEvents(time, descendant);
					}

					if (FocusLog.isLoggable(PlatformLogger.Level.FINEST))
					{
						FocusLog.finest("3. SNFH_HANDLED for lightweight" + descendant + " in " + heavyweight);
					}
					return SNFH_SUCCESS_HANDLED;
				}
				else
				{
					if (!focusedWindowChangeAllowed)
					{
						// For purposes of computing oldFocusedWindow, we should look at
						// the second to last HeavyweightFocusRequest on the queue iff the
						// last HeavyweightFocusRequest is CLEAR_GLOBAL_FOCUS_OWNER. If
						// there is no second to last HeavyweightFocusRequest, null is an
						// acceptable value.
						if (hwFocusRequest == HeavyweightFocusRequest.CLEAR_GLOBAL_FOCUS_OWNER)
						{
							int size = HeavyweightRequests.Count;
							hwFocusRequest = (HeavyweightFocusRequest)((size >= 2) ? HeavyweightRequests.get(size - 2) : null);
						}
						if (FocusedWindowChanged(heavyweight, (hwFocusRequest != null) ? hwFocusRequest.Heavyweight : nativeFocusedWindow))
						{
							if (FocusLog.isLoggable(PlatformLogger.Level.FINEST))
							{
								FocusLog.finest("4. SNFH_FAILURE for " + descendant);
							}
							return SNFH_FAILURE;
						}
					}

					manager.EnqueueKeyEvents(time, descendant);
					HeavyweightRequests.AddLast(new HeavyweightFocusRequest(heavyweight, descendant, temporary, cause));
					if (FocusLog.isLoggable(PlatformLogger.Level.FINEST))
					{
						FocusLog.finest("5. SNFH_PROCEED for " + descendant);
					}
					return SNFH_SUCCESS_PROCEED;
				}
			}
		}

		/// <summary>
		/// Returns the Window which will be active after processing this request,
		/// or null if this is a duplicate request. The active Window is useful
		/// because some native platforms do not support setting the native focus
		/// owner to null. On these platforms, the obvious choice is to set the
		/// focus owner to the focus proxy of the active Window.
		/// </summary>
		internal static Window MarkClearGlobalFocusOwner()
		{
			// need to call this out of synchronized block to avoid possible deadlock
			// see 6454631.
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final Component nativeFocusedWindow = getCurrentKeyboardFocusManager().getNativeFocusedWindow();
			Component nativeFocusedWindow = CurrentKeyboardFocusManager.NativeFocusedWindow;

			lock (HeavyweightRequests)
			{
				HeavyweightFocusRequest hwFocusRequest = LastHWRequest;
				if (hwFocusRequest == HeavyweightFocusRequest.CLEAR_GLOBAL_FOCUS_OWNER)
				{
					// duplicate request
					return null;
				}

				HeavyweightRequests.AddLast(HeavyweightFocusRequest.CLEAR_GLOBAL_FOCUS_OWNER);

				Component activeWindow = ((hwFocusRequest != null) ? SunToolkit.getContainingWindow(hwFocusRequest.Heavyweight) : nativeFocusedWindow);
				while (activeWindow != null && !((activeWindow is Frame) || (activeWindow is Dialog)))
				{
					activeWindow = activeWindow.Parent_NoClientCode;
				}

				return (Window) activeWindow;
			}
		}
		internal virtual Component GetCurrentWaitingRequest(Component parent)
		{
			lock (HeavyweightRequests)
			{
				HeavyweightFocusRequest hwFocusRequest = FirstHWRequest;
				if (hwFocusRequest != null)
				{
					if (hwFocusRequest.Heavyweight == parent)
					{
						LightweightFocusRequest lwFocusRequest = hwFocusRequest.LightweightRequests.First.Value;
						if (lwFocusRequest != null)
						{
							return lwFocusRequest.Component;
						}
					}
				}
			}
			return null;
		}

		internal static bool AutoFocusTransferEnabled
		{
			get
			{
				lock (HeavyweightRequests)
				{
					return (HeavyweightRequests.Count == 0) && !DisableRestoreFocus && (null == CurrentLightweightRequests);
				}
			}
		}

		internal static bool IsAutoFocusTransferEnabledFor(Component comp)
		{
			return AutoFocusTransferEnabled && comp.AutoFocusTransferOnDisposal;
		}

		/*
		 * Used to process exceptions in dispatching focus event (in focusLost/focusGained callbacks).
		 * @param ex previously caught exception that may be processed right here, or null
		 * @param comp the component to dispatch the event to
		 * @param event the event to dispatch to the component
		 */
		private static Throwable DispatchAndCatchException(Throwable ex, Component comp, FocusEvent @event)
		{
			Throwable retEx = null;
			try
			{
				comp.DispatchEvent(@event);
			}
			catch (RuntimeException re)
			{
				retEx = re;
			}
			catch (Error er)
			{
				retEx = er;
			}
			if (retEx != null)
			{
				if (ex != null)
				{
					HandleException(ex);
				}
				return retEx;
			}
			return ex;
		}

		private static void HandleException(Throwable ex)
		{
			ex.PrintStackTrace();
		}

		internal static void ProcessCurrentLightweightRequests()
		{
			KeyboardFocusManager manager = CurrentKeyboardFocusManager;
			LinkedList<LightweightFocusRequest> localLightweightRequests = null;

			Component globalFocusOwner = manager.GlobalFocusOwner;
			if ((globalFocusOwner != null) && (globalFocusOwner.AppContext != AppContext.AppContext))
			{
				// The current app context differs from the app context of a focus
				// owner (and all pending lightweight requests), so we do nothing
				// now and wait for a next event.
				return;
			}

			lock (HeavyweightRequests)
			{
				if (CurrentLightweightRequests != null)
				{
					ClearingCurrentLightweightRequests = true;
					DisableRestoreFocus = true;
					localLightweightRequests = CurrentLightweightRequests;
					AllowSyncFocusRequests = (localLightweightRequests.Count < 2);
					CurrentLightweightRequests = null;
				}
				else
				{
					// do nothing
					return;
				}
			}

			Throwable caughtEx = null;
			try
			{
				if (localLightweightRequests != null)
				{
					Component lastFocusOwner = null;
					Component currentFocusOwner = null;

					for (IEnumerator<KeyboardFocusManager.LightweightFocusRequest> iter = localLightweightRequests.GetEnumerator(); iter.MoveNext();)
					{

						currentFocusOwner = manager.GlobalFocusOwner;
						LightweightFocusRequest lwFocusRequest = iter.Current;

						/*
						 * WARNING: This is based on DKFM's logic solely!
						 *
						 * We allow to trigger restoreFocus() in the dispatching process
						 * only if we have the last request to dispatch. If the last request
						 * fails, focus will be restored to either the component of the last
						 * previously succedded request, or to to the focus owner that was
						 * before this clearing process.
						 */
//JAVA TO C# CONVERTER TODO TASK: Java iterators are only converted within the context of 'while' and 'for' loops:
						if (!iter.hasNext())
						{
							DisableRestoreFocus = false;
						}

						FocusEvent currentFocusOwnerEvent = null;
						/*
						 * We're not dispatching FOCUS_LOST while the current focus owner is null.
						 * But regardless of whether it's null or not, we're clearing ALL the local
						 * lw requests.
						 */
						if (currentFocusOwner != null)
						{
							currentFocusOwnerEvent = new CausedFocusEvent(currentFocusOwner, FocusEvent.FOCUS_LOST, lwFocusRequest.Temporary, lwFocusRequest.Component, lwFocusRequest.Cause);
						}
						FocusEvent newFocusOwnerEvent = new CausedFocusEvent(lwFocusRequest.Component, FocusEvent.FOCUS_GAINED, lwFocusRequest.Temporary, currentFocusOwner == null ? lastFocusOwner : currentFocusOwner, lwFocusRequest.Cause);

						if (currentFocusOwner != null)
						{
							((AWTEvent) currentFocusOwnerEvent).IsPosted = true;
							caughtEx = DispatchAndCatchException(caughtEx, currentFocusOwner, currentFocusOwnerEvent);
						}

						((AWTEvent) newFocusOwnerEvent).IsPosted = true;
						caughtEx = DispatchAndCatchException(caughtEx, lwFocusRequest.Component, newFocusOwnerEvent);

						if (manager.GlobalFocusOwner == lwFocusRequest.Component)
						{
							lastFocusOwner = lwFocusRequest.Component;
						}
					}
				}
			}
			finally
			{
				ClearingCurrentLightweightRequests = false;
				DisableRestoreFocus = false;
				localLightweightRequests = null;
				AllowSyncFocusRequests = true;
			}
			if (caughtEx is RuntimeException)
			{
				throw (RuntimeException)caughtEx;
			}
			else if (caughtEx is Error)
			{
				throw (Error)caughtEx;
			}
		}

		internal static FocusEvent RetargetUnexpectedFocusEvent(FocusEvent fe)
		{
			lock (HeavyweightRequests)
			{
				// Any other case represents a failure condition which we did
				// not expect. We need to clearFocusRequestList() and patch up
				// the event as best as possible.

				if (RemoveFirstRequest())
				{
					return (FocusEvent)RetargetFocusEvent(fe);
				}

				Component source = fe.Component;
				Component opposite = fe.OppositeComponent;
				bool temporary = false;
				if (fe.ID == FocusEvent.FOCUS_LOST && (opposite == null || IsTemporary(opposite, source)))
				{
					temporary = true;
				}
				return new CausedFocusEvent(source, fe.ID, temporary, opposite, CausedFocusEvent.Cause.NATIVE_SYSTEM);
			}
		}

		internal static FocusEvent RetargetFocusGained(FocusEvent fe)
		{
			assert(fe.ID == FocusEvent.FOCUS_GAINED);

			Component currentFocusOwner = CurrentKeyboardFocusManager.GlobalFocusOwner;
			Component source = fe.Component;
			Component opposite = fe.OppositeComponent;
			Component nativeSource = GetHeavyweight(source);

			lock (HeavyweightRequests)
			{
				HeavyweightFocusRequest hwFocusRequest = FirstHWRequest;

				if (hwFocusRequest == HeavyweightFocusRequest.CLEAR_GLOBAL_FOCUS_OWNER)
				{
					return RetargetUnexpectedFocusEvent(fe);
				}

				if (source != null && nativeSource == null && hwFocusRequest != null)
				{
					// if source w/o peer and
					// if source is equal to first lightweight
					// then we should correct source and nativeSource
					if (source == hwFocusRequest.FirstLightweightRequest.Component)
					{
						source = hwFocusRequest.Heavyweight;
						nativeSource = source; // source is heavuweight itself
					}
				}
				if (hwFocusRequest != null && nativeSource == hwFocusRequest.Heavyweight)
				{
					// Focus change as a result of a known call to requestFocus(),
					// or known click on a peer focusable heavyweight Component.

					HeavyweightRequests.RemoveFirst();

					LightweightFocusRequest lwFocusRequest = hwFocusRequest.LightweightRequests.RemoveFirst();

					Component newSource = lwFocusRequest.Component;
					if (currentFocusOwner != null)
					{
						/*
						 * Since we receive FOCUS_GAINED when current focus
						 * owner is not null, correcponding FOCUS_LOST is supposed
						 * to be lost.  And so,  we keep new focus owner
						 * to determine synthetic FOCUS_LOST event which will be
						 * generated by KeyboardFocusManager for this FOCUS_GAINED.
						 *
						 * This code based on knowledge of
						 * DefaultKeyboardFocusManager's implementation and might
						 * be not applicable for another KeyboardFocusManager.
						 */
						NewFocusOwner = newSource;
					}

					bool temporary = (opposite == null || IsTemporary(newSource, opposite)) ? false : lwFocusRequest.Temporary;

					if (hwFocusRequest.LightweightRequests.Count > 0)
					{
						CurrentLightweightRequests = hwFocusRequest.LightweightRequests;
						EventQueue.InvokeLater(new RunnableAnonymousInnerClassHelper());
					}

					// 'opposite' will be fixed by
					// DefaultKeyboardFocusManager.realOppositeComponent
					return new CausedFocusEvent(newSource, FocusEvent.FOCUS_GAINED, temporary, opposite, lwFocusRequest.Cause);
				}

				if (currentFocusOwner != null && currentFocusOwner.ContainingWindow == source && (hwFocusRequest == null || source != hwFocusRequest.Heavyweight))
				{
					// Special case for FOCUS_GAINED in top-levels
					// If it arrives as the result of activation we should skip it
					// This event will not have appropriate request record and
					// on arrival there will be already some focus owner set.
					return new CausedFocusEvent(currentFocusOwner, FocusEvent.FOCUS_GAINED, false, null, CausedFocusEvent.Cause.ACTIVATION);
				}

				return RetargetUnexpectedFocusEvent(fe);
			} // end synchronized(heavyweightRequests)
		}

		private class RunnableAnonymousInnerClassHelper : Runnable
		{
			public RunnableAnonymousInnerClassHelper()
			{
			}

			public virtual void Run()
			{
				ProcessCurrentLightweightRequests();
			}
		}

		internal static FocusEvent RetargetFocusLost(FocusEvent fe)
		{
			assert(fe.ID == FocusEvent.FOCUS_LOST);

			Component currentFocusOwner = CurrentKeyboardFocusManager.GlobalFocusOwner;
			Component opposite = fe.OppositeComponent;
			Component nativeOpposite = GetHeavyweight(opposite);

			lock (HeavyweightRequests)
			{
				HeavyweightFocusRequest hwFocusRequest = FirstHWRequest;

				if (hwFocusRequest == HeavyweightFocusRequest.CLEAR_GLOBAL_FOCUS_OWNER)
				{
					if (currentFocusOwner != null)
					{
						// Call to KeyboardFocusManager.clearGlobalFocusOwner()
						HeavyweightRequests.RemoveFirst();
						return new CausedFocusEvent(currentFocusOwner, FocusEvent.FOCUS_LOST, false, null, CausedFocusEvent.Cause.CLEAR_GLOBAL_FOCUS_OWNER);
					}

					// Otherwise, fall through to failure case below

				}
				else if (opposite == null)
				{
					// Focus leaving application
					if (currentFocusOwner != null)
					{
						return new CausedFocusEvent(currentFocusOwner, FocusEvent.FOCUS_LOST, true, null, CausedFocusEvent.Cause.ACTIVATION);
					}
					else
					{
						return fe;
					}
				}
				else if (hwFocusRequest != null && (nativeOpposite == hwFocusRequest.Heavyweight || nativeOpposite == null && opposite == hwFocusRequest.FirstLightweightRequest.Component))
				{
					if (currentFocusOwner == null)
					{
						return fe;
					}
					// Focus change as a result of a known call to requestFocus(),
					// or click on a peer focusable heavyweight Component.
					// If a focus transfer is made across top-levels, then the
					// FOCUS_LOST event is always temporary, and the FOCUS_GAINED
					// event is always permanent. Otherwise, the stored temporary
					// value is honored.

					LightweightFocusRequest lwFocusRequest = hwFocusRequest.LightweightRequests.First.Value;

					bool temporary = IsTemporary(opposite, currentFocusOwner) ? true : lwFocusRequest.Temporary;

					return new CausedFocusEvent(currentFocusOwner, FocusEvent.FOCUS_LOST, temporary, lwFocusRequest.Component, lwFocusRequest.Cause);
				}
				else if (FocusedWindowChanged(opposite, currentFocusOwner))
				{
					// If top-level changed there might be no focus request in a list
					// But we know the opposite, we now it is temporary - dispatch the event.
					if (!fe.Temporary && currentFocusOwner != null)
					{
						// Create copy of the event with only difference in temporary parameter.
						fe = new CausedFocusEvent(currentFocusOwner, FocusEvent.FOCUS_LOST, true, opposite, CausedFocusEvent.Cause.ACTIVATION);
					}
					return fe;
				}

				return RetargetUnexpectedFocusEvent(fe);
			} // end synchronized(heavyweightRequests)
		}

		internal static AWTEvent RetargetFocusEvent(AWTEvent @event)
		{
			if (ClearingCurrentLightweightRequests)
			{
				return @event;
			}

			KeyboardFocusManager manager = CurrentKeyboardFocusManager;
			if (FocusLog.isLoggable(PlatformLogger.Level.FINER))
			{
				if (@event is FocusEvent || @event is WindowEvent)
				{
					FocusLog.finer(">>> {0}", Convert.ToString(@event));
				}
				if (FocusLog.isLoggable(PlatformLogger.Level.FINER) && @event is KeyEvent)
				{
					FocusLog.finer("    focus owner is {0}", Convert.ToString(manager.GlobalFocusOwner));
					FocusLog.finer(">>> {0}", Convert.ToString(@event));
				}
			}

			lock (HeavyweightRequests)
			{
				/*
				 * This code handles FOCUS_LOST event which is generated by
				 * DefaultKeyboardFocusManager for FOCUS_GAINED.
				 *
				 * This code based on knowledge of DefaultKeyboardFocusManager's
				 * implementation and might be not applicable for another
				 * KeyboardFocusManager.
				 *
				 * Fix for 4472032
				 */
				if (NewFocusOwner != null && @event.ID == FocusEvent.FOCUS_LOST)
				{
					FocusEvent fe = (FocusEvent)@event;

					if (manager.GlobalFocusOwner == fe.Component && fe.OppositeComponent == NewFocusOwner)
					{
						NewFocusOwner = null;
						return @event;
					}
				}
			}

			ProcessCurrentLightweightRequests();

			switch (@event.ID)
			{
				case FocusEvent.FOCUS_GAINED:
				{
					@event = RetargetFocusGained((FocusEvent)@event);
					break;
				}
				case FocusEvent.FOCUS_LOST:
				{
					@event = RetargetFocusLost((FocusEvent)@event);
					break;
				}
				default:
					/* do nothing */
			break;
			}
			return @event;
		}

		/// <summary>
		/// Clears markers queue
		/// This method is not intended to be overridden by KFM's.
		/// Only DefaultKeyboardFocusManager can implement it.
		/// @since 1.5
		/// </summary>
		internal virtual void ClearMarkers()
		{
		}

		internal static bool RemoveFirstRequest()
		{
			KeyboardFocusManager manager = KeyboardFocusManager.CurrentKeyboardFocusManager;

			lock (HeavyweightRequests)
			{
				HeavyweightFocusRequest hwFocusRequest = FirstHWRequest;

				if (hwFocusRequest != null)
				{
					HeavyweightRequests.RemoveFirst();
					if (hwFocusRequest.LightweightRequests != null)
					{
						for (IEnumerator<KeyboardFocusManager.LightweightFocusRequest> lwIter = hwFocusRequest.LightweightRequests.GetEnumerator(); lwIter.MoveNext();)
						{
							manager.DequeueKeyEvents(-1, lwIter.Current.component);
						}
					}
				}
				// Fix for 4799136 - clear type-ahead markers if requests queue is empty
				// We do it here because this method is called only when problems happen
				if (HeavyweightRequests.Count == 0)
				{
					manager.ClearMarkers();
				}
				return (HeavyweightRequests.Count > 0);
			}
		}
		internal static void RemoveLastFocusRequest(Component heavyweight)
		{
			if (Log.isLoggable(PlatformLogger.Level.FINE))
			{
				if (heavyweight == null)
				{
					Log.fine("Assertion (heavyweight != null) failed");
				}
			}

			KeyboardFocusManager manager = KeyboardFocusManager.CurrentKeyboardFocusManager;
			lock (HeavyweightRequests)
			{
				HeavyweightFocusRequest hwFocusRequest = LastHWRequest;
				if (hwFocusRequest != null && hwFocusRequest.Heavyweight == heavyweight)
				{
					HeavyweightRequests.RemoveLast();
				}
				// Fix for 4799136 - clear type-ahead markers if requests queue is empty
				// We do it here because this method is called only when problems happen
				if (HeavyweightRequests.Count == 0)
				{
					manager.ClearMarkers();
				}
			}
		}

		private static bool FocusedWindowChanged(Component to, Component from)
		{
			Window wto = SunToolkit.getContainingWindow(to);
			Window wfrom = SunToolkit.getContainingWindow(from);
			if (wto == null && wfrom == null)
			{
				return true;
			}
			if (wto == null)
			{
				return true;
			}
			if (wfrom == null)
			{
				return true;
			}
			return (wto != wfrom);
		}

		private static bool IsTemporary(Component to, Component from)
		{
			Window wto = SunToolkit.getContainingWindow(to);
			Window wfrom = SunToolkit.getContainingWindow(from);
			if (wto == null && wfrom == null)
			{
				return false;
			}
			if (wto == null)
			{
				return true;
			}
			if (wfrom == null)
			{
				return false;
			}
			return (wto != wfrom);
		}

		internal static Component GetHeavyweight(Component comp)
		{
			if (comp == null || comp.Peer == null)
			{
				return null;
			}
			else if (comp.Peer is LightweightPeer)
			{
				return comp.NativeContainer;
			}
			else
			{
				return comp;
			}
		}

		internal static Field ProxyActive;
		// Accessor to private field isProxyActive of KeyEvent
		private static bool IsProxyActiveImpl(KeyEvent e)
		{
			if (ProxyActive == null)
			{
				ProxyActive = AccessController.doPrivileged(new PrivilegedActionAnonymousInnerClassHelper());
			}

			try
			{
				return ProxyActive.getBoolean(e);
			}
			catch (IllegalAccessException)
			{
				assert(false);
			}
			return false;
		}

		private class PrivilegedActionAnonymousInnerClassHelper : PrivilegedAction<Field>
		{
			public PrivilegedActionAnonymousInnerClassHelper()
			{
			}

			public virtual Field Run()
			{
				Field field = null;
				try
				{
					field = typeof(KeyEvent).getDeclaredField("isProxyActive");
					if (field != null)
					{
						field.Accessible = true;
					}
				}
				catch (NoSuchFieldException)
				{
					assert(false);
				}
				return field;
			}
		}

		// Returns the value of this KeyEvent's field isProxyActive
		internal static bool IsProxyActive(KeyEvent e)
		{
			if (!GraphicsEnvironment.Headless)
			{
				return IsProxyActiveImpl(e);
			}
			else
			{
				return false;
			}
		}

		private static HeavyweightFocusRequest LastHWRequest
		{
			get
			{
				lock (HeavyweightRequests)
				{
					return (HeavyweightRequests.Count > 0) ? HeavyweightRequests.Last.Value : null;
				}
			}
		}

		private static HeavyweightFocusRequest FirstHWRequest
		{
			get
			{
				lock (HeavyweightRequests)
				{
					return (HeavyweightRequests.Count > 0) ? HeavyweightRequests.First.Value : null;
				}
			}
		}

//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: private static void checkReplaceKFMPermission() throws SecurityException
		private static void CheckReplaceKFMPermission()
		{
			SecurityManager security = System.SecurityManager;
			if (security != null)
			{
				if (ReplaceKeyboardFocusManagerPermission == null)
				{
					ReplaceKeyboardFocusManagerPermission = new AWTPermission("replaceKeyboardFocusManager");
				}
				security.CheckPermission(ReplaceKeyboardFocusManagerPermission);
			}
		}

		// Checks if this KeyboardFocusManager instance is the current KFM,
		// or otherwise checks if the calling thread has "replaceKeyboardFocusManager"
		// permission. Here's the reasoning to do so:
		//
		// A system KFM instance (which is the current KFM by default) may have no
		// "replaceKFM" permission when a client code is on the call stack beneath,
		// but still it should be able to execute the methods protected by this check
		// due to the system KFM is trusted (and so it does like "privileged").
		//
		// If this KFM instance is not the current KFM but the client code has all
		// permissions we can't throw SecurityException because it would contradict
		// the security concepts. In this case the trusted client code is responsible
		// for calling the secured methods from KFM instance which is not current.
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: private void checkKFMSecurity() throws SecurityException
		private void CheckKFMSecurity()
		{
			if (this != CurrentKeyboardFocusManager)
			{
				CheckReplaceKFMPermission();
			}
		}
	}

}