/*
 * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

namespace java.util
{


	/// <summary>
	/// A generator of uniform pseudorandom values applicable for use in
	/// (among other contexts) isolated parallel computations that may
	/// generate subtasks. Class {@code SplittableRandom} supports methods for
	/// producing pseudorandom numbers of type {@code int}, {@code long},
	/// and {@code double} with similar usages as for class
	/// <seealso cref="java.util.Random"/> but differs in the following ways:
	/// 
	/// <ul>
	/// 
	/// <li>Series of generated values pass the DieHarder suite testing
	/// independence and uniformity properties of random number generators.
	/// (Most recently validated with <a
	/// href="http://www.phy.duke.edu/~rgb/General/dieharder.php"> version
	/// 3.31.1</a>.) These tests validate only the methods for certain
	/// types and ranges, but similar properties are expected to hold, at
	/// least approximately, for others as well. The <em>period</em>
	/// (length of any series of generated values before it repeats) is at
	/// least 2<sup>64</sup>. </li>
	/// 
	/// <li> Method <seealso cref="#split"/> constructs and returns a new
	/// SplittableRandom instance that shares no mutable state with the
	/// current instance. However, with very high probability, the
	/// values collectively generated by the two objects have the same
	/// statistical properties as if the same quantity of values were
	/// generated by a single thread using a single {@code
	/// SplittableRandom} object.  </li>
	/// 
	/// <li>Instances of SplittableRandom are <em>not</em> thread-safe.
	/// They are designed to be split, not shared, across threads. For
	/// example, a {@link java.util.concurrent.ForkJoinTask
	/// fork/join-style} computation using random numbers might include a
	/// construction of the form {@code new
	/// Subtask(aSplittableRandom.split()).fork()}.
	/// 
	/// <li>This class provides additional methods for generating random
	/// streams, that employ the above techniques when used in {@code
	/// stream.parallel()} mode.</li>
	/// 
	/// </ul>
	/// 
	/// <para>Instances of {@code SplittableRandom} are not cryptographically
	/// secure.  Consider instead using <seealso cref="java.security.SecureRandom"/>
	/// in security-sensitive applications. Additionally,
	/// default-constructed instances do not use a cryptographically random
	/// seed unless the <seealso cref="System#getProperty system property"/>
	/// {@code java.util.secureRandomSeed} is set to {@code true}.
	/// 
	/// @author  Guy Steele
	/// @author  Doug Lea
	/// @since   1.8
	/// </para>
	/// </summary>
	public sealed class SplittableRandom
	{

		/*
		 * Implementation Overview.
		 *
		 * This algorithm was inspired by the "DotMix" algorithm by
		 * Leiserson, Schardl, and Sukha "Deterministic Parallel
		 * Random-Number Generation for Dynamic-Multithreading Platforms",
		 * PPoPP 2012, as well as those in "Parallel random numbers: as
		 * easy as 1, 2, 3" by Salmon, Morae, Dror, and Shaw, SC 2011.  It
		 * differs mainly in simplifying and cheapening operations.
		 *
		 * The primary update step (method nextSeed()) is to add a
		 * constant ("gamma") to the current (64 bit) seed, forming a
		 * simple sequence.  The seed and the gamma values for any two
		 * SplittableRandom instances are highly likely to be different.
		 *
		 * Methods nextLong, nextInt, and derivatives do not return the
		 * sequence (seed) values, but instead a hash-like bit-mix of
		 * their bits, producing more independently distributed sequences.
		 * For nextLong, the mix64 function is based on David Stafford's
		 * (http://zimbry.blogspot.com/2011/09/better-bit-mixing-improving-on.html)
		 * "Mix13" variant of the "64-bit finalizer" function in Austin
		 * Appleby's MurmurHash3 algorithm (see
		 * http://code.google.com/p/smhasher/wiki/MurmurHash3). The mix32
		 * function is based on Stafford's Mix04 mix function, but returns
		 * the upper 32 bits cast as int.
		 *
		 * The split operation uses the current generator to form the seed
		 * and gamma for another SplittableRandom.  To conservatively
		 * avoid potential correlations between seed and value generation,
		 * gamma selection (method mixGamma) uses different
		 * (Murmurhash3's) mix constants.  To avoid potential weaknesses
		 * in bit-mixing transformations, we restrict gammas to odd values
		 * with at least 24 0-1 or 1-0 bit transitions.  Rather than
		 * rejecting candidates with too few or too many bits set, method
		 * mixGamma flips some bits (which has the effect of mapping at
		 * most 4 to any given gamma value).  This reduces the effective
		 * set of 64bit odd gamma values by about 2%, and serves as an
		 * automated screening for sequence constant selection that is
		 * left as an empirical decision in some other hashing and crypto
		 * algorithms.
		 *
		 * The resulting generator thus transforms a sequence in which
		 * (typically) many bits change on each step, with an inexpensive
		 * mixer with good (but less than cryptographically secure)
		 * avalanching.
		 *
		 * The default (no-argument) constructor, in essence, invokes
		 * split() for a common "defaultGen" SplittableRandom.  Unlike
		 * other cases, this split must be performed in a thread-safe
		 * manner, so we use an AtomicLong to represent the seed rather
		 * than use an explicit SplittableRandom. To bootstrap the
		 * defaultGen, we start off using a seed based on current time
		 * unless the java.util.secureRandomSeed property is set. This
		 * serves as a slimmed-down (and insecure) variant of SecureRandom
		 * that also avoids stalls that may occur when using /dev/random.
		 *
		 * It is a relatively simple matter to apply the basic design here
		 * to use 128 bit seeds. However, emulating 128bit arithmetic and
		 * carrying around twice the state add more overhead than appears
		 * warranted for current usages.
		 *
		 * File organization: First the non-public methods that constitute
		 * the main algorithm, then the main public methods, followed by
		 * some custom spliterator classes needed for stream methods.
		 */

		/// <summary>
		/// The golden ratio scaled to 64bits, used as the initial gamma
		/// value for (unsplit) SplittableRandoms.
		/// </summary>
		private const long GOLDEN_GAMMA = unchecked((long)0x9e3779b97f4a7c15L);

		/// <summary>
		/// The least non-zero value returned by nextDouble(). This value
		/// is scaled by a random value of 53 bits to produce a result.
		/// </summary>
		private static readonly double DOUBLE_UNIT = 0x1.0p - 53; // 1.0 / (1L << 53);

		/// <summary>
		/// The seed. Updated only via method nextSeed.
		/// </summary>
		private long Seed;

		/// <summary>
		/// The step value.
		/// </summary>
		private readonly long Gamma;

		/// <summary>
		/// Internal constructor used by all others except default constructor.
		/// </summary>
		private SplittableRandom(long seed, long gamma)
		{
			this.Seed = seed;
			this.Gamma = gamma;
		}

		/// <summary>
		/// Computes Stafford variant 13 of 64bit mix function.
		/// </summary>
		private static long Mix64(long z)
		{
			z = (z ^ ((long)((ulong)z >> 30))) * unchecked((long)0xbf58476d1ce4e5b9L);
			z = (z ^ ((long)((ulong)z >> 27))) * unchecked((long)0x94d049bb133111ebL);
			return z ^ ((long)((ulong)z >> 31));
		}

		/// <summary>
		/// Returns the 32 high bits of Stafford variant 4 mix64 function as int.
		/// </summary>
		private static int Mix32(long z)
		{
			z = (z ^ ((long)((ulong)z >> 33))) * 0x62a9d9ed799705f5L;
			return (int)((int)((uint)((z ^ ((long)((ulong)z >> 28))) * 0xcb24d0a5c88c35b3L) >> 32));
		}

		/// <summary>
		/// Returns the gamma value to use for a new split instance.
		/// </summary>
		private static long MixGamma(long z)
		{
			z = (z ^ ((long)((ulong)z >> 33))) * unchecked((long)0xff51afd7ed558ccdL); // MurmurHash3 mix constants
			z = (z ^ ((long)((ulong)z >> 33))) * unchecked((long)0xc4ceb9fe1a85ec53L);
			z = (z ^ ((long)((ulong)z >> 33))) | 1L; // force to be odd
			int n = Long.BitCount(z ^ ((long)((ulong)z >> 1))); // ensure enough transitions
			return (n < 24) ? z ^ 0xaaaaaaaaaaaaaaaaL : z;
		}

		/// <summary>
		/// Adds gamma to seed.
		/// </summary>
		private long NextSeed()
		{
			return Seed += Gamma;
		}

		/// <summary>
		/// The seed generator for default constructors.
		/// </summary>
		private static readonly AtomicLong DefaultGen = new AtomicLong(InitialSeed());

		private static long InitialSeed()
		{
			String pp = java.security.AccessController.doPrivileged(new sun.security.action.GetPropertyAction("java.util.secureRandomSeed"));
			if (pp != null && pp.EqualsIgnoreCase("true"))
			{
				sbyte[] seedBytes = java.security.SecureRandom.GetSeed(8);
				long s = (long)(seedBytes[0]) & 0xffL;
				for (int i = 1; i < 8; ++i)
				{
					s = (s << 8) | ((long)(seedBytes[i]) & 0xffL);
				}
				return s;
			}
			return (Mix64(DateTimeHelperClass.CurrentUnixTimeMillis()) ^ Mix64(System.nanoTime()));
		}

		// IllegalArgumentException messages
		internal const String BadBound = "bound must be positive";
		internal const String BadRange = "bound must be greater than origin";
		internal const String BadSize = "size must be non-negative";

		/*
		 * Internal versions of nextX methods used by streams, as well as
		 * the public nextX(origin, bound) methods.  These exist mainly to
		 * avoid the need for multiple versions of stream spliterators
		 * across the different exported forms of streams.
		 */

		/// <summary>
		/// The form of nextLong used by LongStream Spliterators.  If
		/// origin is greater than bound, acts as unbounded form of
		/// nextLong, else as bounded form.
		/// </summary>
		/// <param name="origin"> the least value, unless greater than bound </param>
		/// <param name="bound"> the upper bound (exclusive), must not equal origin </param>
		/// <returns> a pseudorandom value </returns>
		internal long InternalNextLong(long origin, long bound)
		{
			/*
			 * Four Cases:
			 *
			 * 1. If the arguments indicate unbounded form, act as
			 * nextLong().
			 *
			 * 2. If the range is an exact power of two, apply the
			 * associated bit mask.
			 *
			 * 3. If the range is positive, loop to avoid potential bias
			 * when the implicit nextLong() bound (2<sup>64</sup>) is not
			 * evenly divisible by the range. The loop rejects candidates
			 * computed from otherwise over-represented values.  The
			 * expected number of iterations under an ideal generator
			 * varies from 1 to 2, depending on the bound. The loop itself
			 * takes an unlovable form. Because the first candidate is
			 * already available, we need a break-in-the-middle
			 * construction, which is concisely but cryptically performed
			 * within the while-condition of a body-less for loop.
			 *
			 * 4. Otherwise, the range cannot be represented as a positive
			 * long.  The loop repeatedly generates unbounded longs until
			 * obtaining a candidate meeting constraints (with an expected
			 * number of iterations of less than two).
			 */

			long r = Mix64(NextSeed());
			if (origin < bound)
			{
				long n = bound - origin, m = n - 1;
				if ((n & m) == 0L) // power of two
				{
					r = (r & m) + origin;
				}
				else if (n > 0L) // reject over-represented candidates
				{
					for (long u = (long)((ulong)r >> 1); u + m - (r = u % n) < 0L; u = (int)((uint)Mix64(NextSeed()) >> 1)) // retry -  rejection check -  ensure nonnegative
					{
						;
					}
					r += origin;
				}
				else // range not representable as long
				{
					while (r < origin || r >= bound)
					{
						r = Mix64(NextSeed());
					}
				}
			}
			return r;
		}

		/// <summary>
		/// The form of nextInt used by IntStream Spliterators.
		/// Exactly the same as long version, except for types.
		/// </summary>
		/// <param name="origin"> the least value, unless greater than bound </param>
		/// <param name="bound"> the upper bound (exclusive), must not equal origin </param>
		/// <returns> a pseudorandom value </returns>
		internal int InternalNextInt(int origin, int bound)
		{
			int r = Mix32(NextSeed());
			if (origin < bound)
			{
				int n = bound - origin, m = n - 1;
				if ((n & m) == 0)
				{
					r = (r & m) + origin;
				}
				else if (n > 0)
				{
					for (int u = (int)((uint)r >> 1); u + m - (r = u % n) < 0; u = (int)((uint)Mix32(NextSeed()) >> 1))
					{
						;
					}
					r += origin;
				}
				else
				{
					while (r < origin || r >= bound)
					{
						r = Mix32(NextSeed());
					}
				}
			}
			return r;
		}

		/// <summary>
		/// The form of nextDouble used by DoubleStream Spliterators.
		/// </summary>
		/// <param name="origin"> the least value, unless greater than bound </param>
		/// <param name="bound"> the upper bound (exclusive), must not equal origin </param>
		/// <returns> a pseudorandom value </returns>
		internal double InternalNextDouble(double origin, double bound)
		{
			double r = ((int)((uint)NextLong() >> 11)) * DOUBLE_UNIT;
			if (origin < bound)
			{
				r = r * (bound - origin) + origin;
				if (r >= bound) // correct for rounding
				{
					r = Double.longBitsToDouble(Double.DoubleToLongBits(bound) - 1);
				}
			}
			return r;
		}

		/* ---------------- public methods ---------------- */

		/// <summary>
		/// Creates a new SplittableRandom instance using the specified
		/// initial seed. SplittableRandom instances created with the same
		/// seed in the same program generate identical sequences of values.
		/// </summary>
		/// <param name="seed"> the initial seed </param>
		public SplittableRandom(long seed) : this(seed, GOLDEN_GAMMA)
		{
		}

		/// <summary>
		/// Creates a new SplittableRandom instance that is likely to
		/// generate sequences of values that are statistically independent
		/// of those of any other instances in the current program; and
		/// may, and typically does, vary across program invocations.
		/// </summary>
		public SplittableRandom() // emulate defaultGen.split()
		{
			long s = DefaultGen.GetAndAdd(2 * GOLDEN_GAMMA);
			this.Seed = Mix64(s);
			this.Gamma = MixGamma(s + GOLDEN_GAMMA);
		}

		/// <summary>
		/// Constructs and returns a new SplittableRandom instance that
		/// shares no mutable state with this instance. However, with very
		/// high probability, the set of values collectively generated by
		/// the two objects has the same statistical properties as if the
		/// same quantity of values were generated by a single thread using
		/// a single SplittableRandom object.  Either or both of the two
		/// objects may be further split using the {@code split()} method,
		/// and the same expected statistical properties apply to the
		/// entire set of generators constructed by such recursive
		/// splitting.
		/// </summary>
		/// <returns> the new SplittableRandom instance </returns>
		public SplittableRandom Split()
		{
			return new SplittableRandom(NextLong(), MixGamma(NextSeed()));
		}

		/// <summary>
		/// Returns a pseudorandom {@code int} value.
		/// </summary>
		/// <returns> a pseudorandom {@code int} value </returns>
		public int NextInt()
		{
			return Mix32(NextSeed());
		}

		/// <summary>
		/// Returns a pseudorandom {@code int} value between zero (inclusive)
		/// and the specified bound (exclusive).
		/// </summary>
		/// <param name="bound"> the upper bound (exclusive).  Must be positive. </param>
		/// <returns> a pseudorandom {@code int} value between zero
		///         (inclusive) and the bound (exclusive) </returns>
		/// <exception cref="IllegalArgumentException"> if {@code bound} is not positive </exception>
		public int NextInt(int bound)
		{
			if (bound <= 0)
			{
				throw new IllegalArgumentException(BadBound);
			}
			// Specialize internalNextInt for origin 0
			int r = Mix32(NextSeed());
			int m = bound - 1;
			if ((bound & m) == 0) // power of two
			{
				r &= m;
			}
			else // reject over-represented candidates
			{
				for (int u = (int)((uint)r >> 1); u + m - (r = u % bound) < 0; u = (int)((uint)Mix32(NextSeed()) >> 1))
				{
					;
				}
			}
			return r;
		}

		/// <summary>
		/// Returns a pseudorandom {@code int} value between the specified
		/// origin (inclusive) and the specified bound (exclusive).
		/// </summary>
		/// <param name="origin"> the least value returned </param>
		/// <param name="bound"> the upper bound (exclusive) </param>
		/// <returns> a pseudorandom {@code int} value between the origin
		///         (inclusive) and the bound (exclusive) </returns>
		/// <exception cref="IllegalArgumentException"> if {@code origin} is greater than
		///         or equal to {@code bound} </exception>
		public int NextInt(int origin, int bound)
		{
			if (origin >= bound)
			{
				throw new IllegalArgumentException(BadRange);
			}
			return InternalNextInt(origin, bound);
		}

		/// <summary>
		/// Returns a pseudorandom {@code long} value.
		/// </summary>
		/// <returns> a pseudorandom {@code long} value </returns>
		public long NextLong()
		{
			return Mix64(NextSeed());
		}

		/// <summary>
		/// Returns a pseudorandom {@code long} value between zero (inclusive)
		/// and the specified bound (exclusive).
		/// </summary>
		/// <param name="bound"> the upper bound (exclusive).  Must be positive. </param>
		/// <returns> a pseudorandom {@code long} value between zero
		///         (inclusive) and the bound (exclusive) </returns>
		/// <exception cref="IllegalArgumentException"> if {@code bound} is not positive </exception>
		public long NextLong(long bound)
		{
			if (bound <= 0)
			{
				throw new IllegalArgumentException(BadBound);
			}
			// Specialize internalNextLong for origin 0
			long r = Mix64(NextSeed());
			long m = bound - 1;
			if ((bound & m) == 0L) // power of two
			{
				r &= m;
			}
			else // reject over-represented candidates
			{
				for (long u = (long)((ulong)r >> 1); u + m - (r = u % bound) < 0L; u = (int)((uint)Mix64(NextSeed()) >> 1))
				{
					;
				}
			}
			return r;
		}

		/// <summary>
		/// Returns a pseudorandom {@code long} value between the specified
		/// origin (inclusive) and the specified bound (exclusive).
		/// </summary>
		/// <param name="origin"> the least value returned </param>
		/// <param name="bound"> the upper bound (exclusive) </param>
		/// <returns> a pseudorandom {@code long} value between the origin
		///         (inclusive) and the bound (exclusive) </returns>
		/// <exception cref="IllegalArgumentException"> if {@code origin} is greater than
		///         or equal to {@code bound} </exception>
		public long NextLong(long origin, long bound)
		{
			if (origin >= bound)
			{
				throw new IllegalArgumentException(BadRange);
			}
			return InternalNextLong(origin, bound);
		}

		/// <summary>
		/// Returns a pseudorandom {@code double} value between zero
		/// (inclusive) and one (exclusive).
		/// </summary>
		/// <returns> a pseudorandom {@code double} value between zero
		///         (inclusive) and one (exclusive) </returns>
		public double NextDouble()
		{
			return ((int)((uint)Mix64(NextSeed()) >> 11)) * DOUBLE_UNIT;
		}

		/// <summary>
		/// Returns a pseudorandom {@code double} value between 0.0
		/// (inclusive) and the specified bound (exclusive).
		/// </summary>
		/// <param name="bound"> the upper bound (exclusive).  Must be positive. </param>
		/// <returns> a pseudorandom {@code double} value between zero
		///         (inclusive) and the bound (exclusive) </returns>
		/// <exception cref="IllegalArgumentException"> if {@code bound} is not positive </exception>
		public double NextDouble(double bound)
		{
			if (!(bound > 0.0))
			{
				throw new IllegalArgumentException(BadBound);
			}
			double result = ((int)((uint)Mix64(NextSeed()) >> 11)) * DOUBLE_UNIT * bound;
			return (result < bound) ? result : Double.longBitsToDouble(Double.DoubleToLongBits(bound) - 1); // correct for rounding
		}

		/// <summary>
		/// Returns a pseudorandom {@code double} value between the specified
		/// origin (inclusive) and bound (exclusive).
		/// </summary>
		/// <param name="origin"> the least value returned </param>
		/// <param name="bound"> the upper bound (exclusive) </param>
		/// <returns> a pseudorandom {@code double} value between the origin
		///         (inclusive) and the bound (exclusive) </returns>
		/// <exception cref="IllegalArgumentException"> if {@code origin} is greater than
		///         or equal to {@code bound} </exception>
		public double NextDouble(double origin, double bound)
		{
			if (!(origin < bound))
			{
				throw new IllegalArgumentException(BadRange);
			}
			return InternalNextDouble(origin, bound);
		}

		/// <summary>
		/// Returns a pseudorandom {@code boolean} value.
		/// </summary>
		/// <returns> a pseudorandom {@code boolean} value </returns>
		public bool NextBoolean()
		{
			return Mix32(NextSeed()) < 0;
		}

		// stream methods, coded in a way intended to better isolate for
		// maintenance purposes the small differences across forms.

		/// <summary>
		/// Returns a stream producing the given {@code streamSize} number
		/// of pseudorandom {@code int} values from this generator and/or
		/// one split from it.
		/// </summary>
		/// <param name="streamSize"> the number of values to generate </param>
		/// <returns> a stream of pseudorandom {@code int} values </returns>
		/// <exception cref="IllegalArgumentException"> if {@code streamSize} is
		///         less than zero </exception>
		public IntStream Ints(long streamSize)
		{
			if (streamSize < 0L)
			{
				throw new IllegalArgumentException(BadSize);
			}
			return StreamSupport.IntStream(new RandomIntsSpliterator(this, 0L, streamSize, Integer.MaxValue, 0), false);
		}

		/// <summary>
		/// Returns an effectively unlimited stream of pseudorandom {@code int}
		/// values from this generator and/or one split from it.
		/// 
		/// @implNote This method is implemented to be equivalent to {@code
		/// ints(Long.MAX_VALUE)}.
		/// </summary>
		/// <returns> a stream of pseudorandom {@code int} values </returns>
		public IntStream Ints()
		{
			return StreamSupport.IntStream(new RandomIntsSpliterator(this, 0L, Long.MaxValue, Integer.MaxValue, 0), false);
		}

		/// <summary>
		/// Returns a stream producing the given {@code streamSize} number
		/// of pseudorandom {@code int} values from this generator and/or one split
		/// from it; each value conforms to the given origin (inclusive) and bound
		/// (exclusive).
		/// </summary>
		/// <param name="streamSize"> the number of values to generate </param>
		/// <param name="randomNumberOrigin"> the origin (inclusive) of each random value </param>
		/// <param name="randomNumberBound"> the bound (exclusive) of each random value </param>
		/// <returns> a stream of pseudorandom {@code int} values,
		///         each with the given origin (inclusive) and bound (exclusive) </returns>
		/// <exception cref="IllegalArgumentException"> if {@code streamSize} is
		///         less than zero, or {@code randomNumberOrigin}
		///         is greater than or equal to {@code randomNumberBound} </exception>
		public IntStream Ints(long streamSize, int randomNumberOrigin, int randomNumberBound)
		{
			if (streamSize < 0L)
			{
				throw new IllegalArgumentException(BadSize);
			}
			if (randomNumberOrigin >= randomNumberBound)
			{
				throw new IllegalArgumentException(BadRange);
			}
			return StreamSupport.IntStream(new RandomIntsSpliterator(this, 0L, streamSize, randomNumberOrigin, randomNumberBound), false);
		}

		/// <summary>
		/// Returns an effectively unlimited stream of pseudorandom {@code
		/// int} values from this generator and/or one split from it; each value
		/// conforms to the given origin (inclusive) and bound (exclusive).
		/// 
		/// @implNote This method is implemented to be equivalent to {@code
		/// ints(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.
		/// </summary>
		/// <param name="randomNumberOrigin"> the origin (inclusive) of each random value </param>
		/// <param name="randomNumberBound"> the bound (exclusive) of each random value </param>
		/// <returns> a stream of pseudorandom {@code int} values,
		///         each with the given origin (inclusive) and bound (exclusive) </returns>
		/// <exception cref="IllegalArgumentException"> if {@code randomNumberOrigin}
		///         is greater than or equal to {@code randomNumberBound} </exception>
		public IntStream Ints(int randomNumberOrigin, int randomNumberBound)
		{
			if (randomNumberOrigin >= randomNumberBound)
			{
				throw new IllegalArgumentException(BadRange);
			}
			return StreamSupport.IntStream(new RandomIntsSpliterator(this, 0L, Long.MaxValue, randomNumberOrigin, randomNumberBound), false);
		}

		/// <summary>
		/// Returns a stream producing the given {@code streamSize} number
		/// of pseudorandom {@code long} values from this generator and/or
		/// one split from it.
		/// </summary>
		/// <param name="streamSize"> the number of values to generate </param>
		/// <returns> a stream of pseudorandom {@code long} values </returns>
		/// <exception cref="IllegalArgumentException"> if {@code streamSize} is
		///         less than zero </exception>
		public LongStream Longs(long streamSize)
		{
			if (streamSize < 0L)
			{
				throw new IllegalArgumentException(BadSize);
			}
			return StreamSupport.LongStream(new RandomLongsSpliterator(this, 0L, streamSize, Long.MaxValue, 0L), false);
		}

		/// <summary>
		/// Returns an effectively unlimited stream of pseudorandom {@code
		/// long} values from this generator and/or one split from it.
		/// 
		/// @implNote This method is implemented to be equivalent to {@code
		/// longs(Long.MAX_VALUE)}.
		/// </summary>
		/// <returns> a stream of pseudorandom {@code long} values </returns>
		public LongStream Longs()
		{
			return StreamSupport.LongStream(new RandomLongsSpliterator(this, 0L, Long.MaxValue, Long.MaxValue, 0L), false);
		}

		/// <summary>
		/// Returns a stream producing the given {@code streamSize} number of
		/// pseudorandom {@code long} values from this generator and/or one split
		/// from it; each value conforms to the given origin (inclusive) and bound
		/// (exclusive).
		/// </summary>
		/// <param name="streamSize"> the number of values to generate </param>
		/// <param name="randomNumberOrigin"> the origin (inclusive) of each random value </param>
		/// <param name="randomNumberBound"> the bound (exclusive) of each random value </param>
		/// <returns> a stream of pseudorandom {@code long} values,
		///         each with the given origin (inclusive) and bound (exclusive) </returns>
		/// <exception cref="IllegalArgumentException"> if {@code streamSize} is
		///         less than zero, or {@code randomNumberOrigin}
		///         is greater than or equal to {@code randomNumberBound} </exception>
		public LongStream Longs(long streamSize, long randomNumberOrigin, long randomNumberBound)
		{
			if (streamSize < 0L)
			{
				throw new IllegalArgumentException(BadSize);
			}
			if (randomNumberOrigin >= randomNumberBound)
			{
				throw new IllegalArgumentException(BadRange);
			}
			return StreamSupport.LongStream(new RandomLongsSpliterator(this, 0L, streamSize, randomNumberOrigin, randomNumberBound), false);
		}

		/// <summary>
		/// Returns an effectively unlimited stream of pseudorandom {@code
		/// long} values from this generator and/or one split from it; each value
		/// conforms to the given origin (inclusive) and bound (exclusive).
		/// 
		/// @implNote This method is implemented to be equivalent to {@code
		/// longs(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.
		/// </summary>
		/// <param name="randomNumberOrigin"> the origin (inclusive) of each random value </param>
		/// <param name="randomNumberBound"> the bound (exclusive) of each random value </param>
		/// <returns> a stream of pseudorandom {@code long} values,
		///         each with the given origin (inclusive) and bound (exclusive) </returns>
		/// <exception cref="IllegalArgumentException"> if {@code randomNumberOrigin}
		///         is greater than or equal to {@code randomNumberBound} </exception>
		public LongStream Longs(long randomNumberOrigin, long randomNumberBound)
		{
			if (randomNumberOrigin >= randomNumberBound)
			{
				throw new IllegalArgumentException(BadRange);
			}
			return StreamSupport.LongStream(new RandomLongsSpliterator(this, 0L, Long.MaxValue, randomNumberOrigin, randomNumberBound), false);
		}

		/// <summary>
		/// Returns a stream producing the given {@code streamSize} number of
		/// pseudorandom {@code double} values from this generator and/or one split
		/// from it; each value is between zero (inclusive) and one (exclusive).
		/// </summary>
		/// <param name="streamSize"> the number of values to generate </param>
		/// <returns> a stream of {@code double} values </returns>
		/// <exception cref="IllegalArgumentException"> if {@code streamSize} is
		///         less than zero </exception>
		public DoubleStream Doubles(long streamSize)
		{
			if (streamSize < 0L)
			{
				throw new IllegalArgumentException(BadSize);
			}
			return StreamSupport.DoubleStream(new RandomDoublesSpliterator(this, 0L, streamSize, Double.MaxValue, 0.0), false);
		}

		/// <summary>
		/// Returns an effectively unlimited stream of pseudorandom {@code
		/// double} values from this generator and/or one split from it; each value
		/// is between zero (inclusive) and one (exclusive).
		/// 
		/// @implNote This method is implemented to be equivalent to {@code
		/// doubles(Long.MAX_VALUE)}.
		/// </summary>
		/// <returns> a stream of pseudorandom {@code double} values </returns>
		public DoubleStream Doubles()
		{
			return StreamSupport.DoubleStream(new RandomDoublesSpliterator(this, 0L, Long.MaxValue, Double.MaxValue, 0.0), false);
		}

		/// <summary>
		/// Returns a stream producing the given {@code streamSize} number of
		/// pseudorandom {@code double} values from this generator and/or one split
		/// from it; each value conforms to the given origin (inclusive) and bound
		/// (exclusive).
		/// </summary>
		/// <param name="streamSize"> the number of values to generate </param>
		/// <param name="randomNumberOrigin"> the origin (inclusive) of each random value </param>
		/// <param name="randomNumberBound"> the bound (exclusive) of each random value </param>
		/// <returns> a stream of pseudorandom {@code double} values,
		///         each with the given origin (inclusive) and bound (exclusive) </returns>
		/// <exception cref="IllegalArgumentException"> if {@code streamSize} is
		///         less than zero </exception>
		/// <exception cref="IllegalArgumentException"> if {@code randomNumberOrigin}
		///         is greater than or equal to {@code randomNumberBound} </exception>
		public DoubleStream Doubles(long streamSize, double randomNumberOrigin, double randomNumberBound)
		{
			if (streamSize < 0L)
			{
				throw new IllegalArgumentException(BadSize);
			}
			if (!(randomNumberOrigin < randomNumberBound))
			{
				throw new IllegalArgumentException(BadRange);
			}
			return StreamSupport.DoubleStream(new RandomDoublesSpliterator(this, 0L, streamSize, randomNumberOrigin, randomNumberBound), false);
		}

		/// <summary>
		/// Returns an effectively unlimited stream of pseudorandom {@code
		/// double} values from this generator and/or one split from it; each value
		/// conforms to the given origin (inclusive) and bound (exclusive).
		/// 
		/// @implNote This method is implemented to be equivalent to {@code
		/// doubles(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.
		/// </summary>
		/// <param name="randomNumberOrigin"> the origin (inclusive) of each random value </param>
		/// <param name="randomNumberBound"> the bound (exclusive) of each random value </param>
		/// <returns> a stream of pseudorandom {@code double} values,
		///         each with the given origin (inclusive) and bound (exclusive) </returns>
		/// <exception cref="IllegalArgumentException"> if {@code randomNumberOrigin}
		///         is greater than or equal to {@code randomNumberBound} </exception>
		public DoubleStream Doubles(double randomNumberOrigin, double randomNumberBound)
		{
			if (!(randomNumberOrigin < randomNumberBound))
			{
				throw new IllegalArgumentException(BadRange);
			}
			return StreamSupport.DoubleStream(new RandomDoublesSpliterator(this, 0L, Long.MaxValue, randomNumberOrigin, randomNumberBound), false);
		}

		/// <summary>
		/// Spliterator for int streams.  We multiplex the four int
		/// versions into one class by treating a bound less than origin as
		/// unbounded, and also by treating "infinite" as equivalent to
		/// Long.MAX_VALUE. For splits, it uses the standard divide-by-two
		/// approach. The long and double versions of this class are
		/// identical except for types.
		/// </summary>
		internal sealed class RandomIntsSpliterator : Spliterator_OfInt
		{
			internal readonly SplittableRandom Rng;
			internal long Index;
			internal readonly long Fence;
			internal readonly int Origin;
			internal readonly int Bound;
			internal RandomIntsSpliterator(SplittableRandom rng, long index, long fence, int origin, int bound)
			{
				this.Rng = rng;
				this.Index = index;
				this.Fence = fence;
				this.Origin = origin;
				this.Bound = bound;
			}

			public RandomIntsSpliterator TrySplit()
			{
				long i = Index, m = (int)((uint)(i + Fence) >> 1);
				return (m <= i) ? null : new RandomIntsSpliterator(Rng.Split(), i, Index = m, Origin, Bound);
			}

			public long EstimateSize()
			{
				return Fence - Index;
			}

			public int Characteristics()
			{
				return (Spliterator_Fields.SIZED | Spliterator_Fields.SUBSIZED | Spliterator_Fields.NONNULL | Spliterator_Fields.IMMUTABLE);
			}

			public bool TryAdvance(IntConsumer consumer)
			{
				if (consumer == null)
				{
					throw new NullPointerException();
				}
				long i = Index, f = Fence;
				if (i < f)
				{
					consumer.Accept(Rng.InternalNextInt(Origin, Bound));
					Index = i + 1;
					return true;
				}
				return false;
			}

			public void ForEachRemaining(IntConsumer consumer)
			{
				if (consumer == null)
				{
					throw new NullPointerException();
				}
				long i = Index, f = Fence;
				if (i < f)
				{
					Index = f;
					SplittableRandom r = Rng;
					int o = Origin, b = Bound;
					do
					{
						consumer.Accept(r.InternalNextInt(o, b));
					} while (++i < f);
				}
			}
		}

		/// <summary>
		/// Spliterator for long streams.
		/// </summary>
		internal sealed class RandomLongsSpliterator : Spliterator_OfLong
		{
			internal readonly SplittableRandom Rng;
			internal long Index;
			internal readonly long Fence;
			internal readonly long Origin;
			internal readonly long Bound;
			internal RandomLongsSpliterator(SplittableRandom rng, long index, long fence, long origin, long bound)
			{
				this.Rng = rng;
				this.Index = index;
				this.Fence = fence;
				this.Origin = origin;
				this.Bound = bound;
			}

			public RandomLongsSpliterator TrySplit()
			{
				long i = Index, m = (int)((uint)(i + Fence) >> 1);
				return (m <= i) ? null : new RandomLongsSpliterator(Rng.Split(), i, Index = m, Origin, Bound);
			}

			public long EstimateSize()
			{
				return Fence - Index;
			}

			public int Characteristics()
			{
				return (Spliterator_Fields.SIZED | Spliterator_Fields.SUBSIZED | Spliterator_Fields.NONNULL | Spliterator_Fields.IMMUTABLE);
			}

			public bool TryAdvance(LongConsumer consumer)
			{
				if (consumer == null)
				{
					throw new NullPointerException();
				}
				long i = Index, f = Fence;
				if (i < f)
				{
					consumer.Accept(Rng.InternalNextLong(Origin, Bound));
					Index = i + 1;
					return true;
				}
				return false;
			}

			public void ForEachRemaining(LongConsumer consumer)
			{
				if (consumer == null)
				{
					throw new NullPointerException();
				}
				long i = Index, f = Fence;
				if (i < f)
				{
					Index = f;
					SplittableRandom r = Rng;
					long o = Origin, b = Bound;
					do
					{
						consumer.Accept(r.InternalNextLong(o, b));
					} while (++i < f);
				}
			}

		}

		/// <summary>
		/// Spliterator for double streams.
		/// </summary>
		internal sealed class RandomDoublesSpliterator : Spliterator_OfDouble
		{
			internal readonly SplittableRandom Rng;
			internal long Index;
			internal readonly long Fence;
			internal readonly double Origin;
			internal readonly double Bound;
			internal RandomDoublesSpliterator(SplittableRandom rng, long index, long fence, double origin, double bound)
			{
				this.Rng = rng;
				this.Index = index;
				this.Fence = fence;
				this.Origin = origin;
				this.Bound = bound;
			}

			public RandomDoublesSpliterator TrySplit()
			{
				long i = Index, m = (int)((uint)(i + Fence) >> 1);
				return (m <= i) ? null : new RandomDoublesSpliterator(Rng.Split(), i, Index = m, Origin, Bound);
			}

			public long EstimateSize()
			{
				return Fence - Index;
			}

			public int Characteristics()
			{
				return (Spliterator_Fields.SIZED | Spliterator_Fields.SUBSIZED | Spliterator_Fields.NONNULL | Spliterator_Fields.IMMUTABLE);
			}

			public bool TryAdvance(DoubleConsumer consumer)
			{
				if (consumer == null)
				{
					throw new NullPointerException();
				}
				long i = Index, f = Fence;
				if (i < f)
				{
					consumer.Accept(Rng.InternalNextDouble(Origin, Bound));
					Index = i + 1;
					return true;
				}
				return false;
			}

			public void ForEachRemaining(DoubleConsumer consumer)
			{
				if (consumer == null)
				{
					throw new NullPointerException();
				}
				long i = Index, f = Fence;
				if (i < f)
				{
					Index = f;
					SplittableRandom r = Rng;
					double o = Origin, b = Bound;
					do
					{
						consumer.Accept(r.InternalNextDouble(o, b));
					} while (++i < f);
				}
			}
		}

	}

}