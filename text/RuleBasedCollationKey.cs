/*
 * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

/*
 * (C) Copyright Taligent, Inc. 1996 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */

namespace java.text
{

	/// <summary>
	/// A RuleBasedCollationKey is a concrete implementation of CollationKey class.
	/// The RuleBasedCollationKey class is used by the RuleBasedCollator class.
	/// </summary>

	internal sealed class RuleBasedCollationKey : CollationKey
	{
		/// <summary>
		/// Compare this RuleBasedCollationKey to target. The collation rules of the
		/// Collator object which created these keys are applied. <strong>Note:</strong>
		/// RuleBasedCollationKeys created by different Collators can not be compared. </summary>
		/// <param name="target"> target RuleBasedCollationKey </param>
		/// <returns> Returns an integer value. Value is less than zero if this is less
		/// than target, value is zero if this and target are equal and value is greater than
		/// zero if this is greater than target. </returns>
		/// <seealso cref= java.text.Collator#compare </seealso>
		public override int CompareTo(CollationKey target)
		{
			int result = Key.CompareTo(((RuleBasedCollationKey)(target)).Key);
			if (result <= Collator.LESS)
			{
				return Collator.LESS;
			}
			else if (result >= Collator.GREATER)
			{
				return Collator.GREATER;
			}
			return Collator.EQUAL;
		}

		/// <summary>
		/// Compare this RuleBasedCollationKey and the target for equality.
		/// The collation rules of the Collator object which created these keys are applied.
		/// <strong>Note:</strong> RuleBasedCollationKeys created by different Collators can not be
		/// compared. </summary>
		/// <param name="target"> the RuleBasedCollationKey to compare to. </param>
		/// <returns> Returns true if two objects are equal, false otherwise. </returns>
		public override bool Equals(Object target)
		{
			if (this == target)
			{
				return true;
			}
			if (target == null || !this.GetType().Equals(target.GetType()))
			{
				return false;
			}
			RuleBasedCollationKey other = (RuleBasedCollationKey)target;
			return Key.Equals(other.Key);
		}

		/// <summary>
		/// Creates a hash code for this RuleBasedCollationKey. The hash value is calculated on the
		/// key itself, not the String from which the key was created.  Thus
		/// if x and y are RuleBasedCollationKeys, then x.hashCode(x) == y.hashCode() if
		/// x.equals(y) is true.  This allows language-sensitive comparison in a hash table.
		/// See the CollatinKey class description for an example. </summary>
		/// <returns> the hash value based on the string's collation order. </returns>
		public override int HashCode()
		{
			return (Key.HashCode());
		}

		/// <summary>
		/// Converts the RuleBasedCollationKey to a sequence of bits. If two RuleBasedCollationKeys
		/// could be legitimately compared, then one could compare the byte arrays
		/// for each of those keys to obtain the same result.  Byte arrays are
		/// organized most significant byte first.
		/// </summary>
		public override sbyte[] ToByteArray()
		{

			char[] src = Key.ToCharArray();
			sbyte[] dest = new sbyte[2 * src.Length];
			int j = 0;
			for (int i = 0; i < src.Length; i++)
			{
				dest[j++] = (sbyte)((int)((uint)src[i] >> 8));
				dest[j++] = unchecked((sbyte)(src[i] & 0x00ff));
			}
			return dest;
		}

		/// <summary>
		/// A RuleBasedCollationKey can only be generated by Collator objects.
		/// </summary>
		internal RuleBasedCollationKey(String source, String key) : base(source)
		{
			this.Key = key;
		}
		private String Key = null;

	}

}