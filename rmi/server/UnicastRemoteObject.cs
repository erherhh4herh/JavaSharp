using System;

/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
namespace java.rmi.server
{

	using UnicastServerRef = sun.rmi.server.UnicastServerRef;
	using UnicastServerRef2 = sun.rmi.server.UnicastServerRef2;

	/// <summary>
	/// Used for exporting a remote object with JRMP and obtaining a stub
	/// that communicates to the remote object. Stubs are either generated
	/// at runtime using dynamic proxy objects, or they are generated statically
	/// at build time, typically using the {@code rmic} tool.
	/// 
	/// <para><strong>Deprecated: Static Stubs.</strong> <em>Support for statically
	/// generated stubs is deprecated. This includes the API in this class that
	/// requires the use of static stubs, as well as the runtime support for
	/// loading static stubs.  Generating stubs dynamically is preferred, using one
	/// of the five non-deprecated ways of exporting objects as listed below. Do
	/// not run {@code rmic} to generate static stub classes. It is unnecessary, and
	/// it is also deprecated.</em>
	/// 
	/// </para>
	/// <para>There are six ways to export remote objects:
	/// 
	/// <ol>
	/// 
	/// <li>Subclassing {@code UnicastRemoteObject} and calling the
	/// <seealso cref="#UnicastRemoteObject()"/> constructor.
	/// 
	/// <li>Subclassing {@code UnicastRemoteObject} and calling the
	/// <seealso cref="#UnicastRemoteObject(int) UnicastRemoteObject(port)"/> constructor.
	/// 
	/// <li>Subclassing {@code UnicastRemoteObject} and calling the
	/// {@link #UnicastRemoteObject(int, RMIClientSocketFactory, RMIServerSocketFactory)
	/// UnicastRemoteObject(port, csf, ssf)} constructor.
	/// 
	/// <li>Calling the
	/// <seealso cref="#exportObject(Remote) exportObject(Remote)"/> method.
	/// <strong>Deprecated.</strong>
	/// 
	/// <li>Calling the
	/// <seealso cref="#exportObject(Remote, int) exportObject(Remote, port)"/> method.
	/// 
	/// <li>Calling the
	/// {@link #exportObject(Remote, int, RMIClientSocketFactory, RMIServerSocketFactory)
	/// exportObject(Remote, port, csf, ssf)} method.
	/// 
	/// </ol>
	/// 
	/// </para>
	/// <para>The fourth technique, <seealso cref="#exportObject(Remote)"/>,
	/// always uses statically generated stubs and is deprecated.
	/// 
	/// </para>
	/// <para>The other five techniques all use the following approach: if the
	/// {@code java.rmi.server.ignoreStubClasses} property is {@code true}
	/// (case insensitive) or if a static stub cannot be found, stubs are generated
	/// dynamically using <seealso cref="java.lang.reflect.Proxy Proxy"/> objects. Otherwise,
	/// static stubs are used.
	/// 
	/// </para>
	/// <para>The default value of the
	/// {@code java.rmi.server.ignoreStubClasses} property is {@code false}.
	/// 
	/// </para>
	/// <para>Statically generated stubs are typically pregenerated from the
	/// remote object's class using the {@code rmic} tool. A static stub is
	/// loaded and an instance of that stub class is constructed as described
	/// below.
	/// 
	/// <ul>
	/// 
	/// <li>A "root class" is determined as follows: if the remote object's
	/// class directly implements an interface that extends <seealso cref="Remote"/>, then
	/// the remote object's class is the root class; otherwise, the root class is
	/// the most derived superclass of the remote object's class that directly
	/// implements an interface that extends {@code Remote}.
	/// 
	/// <li>The name of the stub class to load is determined by concatenating
	/// the binary name of the root class with the suffix {@code _Stub}.
	/// 
	/// <li>The stub class is loaded by name using the class loader of the root
	/// class. The stub class must extend <seealso cref="RemoteStub"/> and must have a
	/// public constructor that has one parameter of type <seealso cref="RemoteRef"/>.
	/// 
	/// <li>Finally, an instance of the stub class is constructed with a
	/// <seealso cref="RemoteRef"/>.
	/// 
	/// <li>If the appropriate stub class could not be found, or if the stub class
	/// could not be loaded, or if a problem occurs creating the stub instance, a
	/// <seealso cref="StubNotFoundException"/> is thrown.
	/// 
	/// </ul>
	/// 
	/// </para>
	/// <para>Stubs are dynamically generated by constructing an instance of
	/// a <seealso cref="java.lang.reflect.Proxy Proxy"/> with the following characteristics:
	/// 
	/// <ul>
	/// 
	/// <li>The proxy's class is defined by the class loader of the remote
	/// object's class.
	/// 
	/// <li>The proxy implements all the remote interfaces implemented by the
	/// remote object's class.
	/// 
	/// <li>The proxy's invocation handler is a {@link
	/// RemoteObjectInvocationHandler} instance constructed with a
	/// <seealso cref="RemoteRef"/>.
	/// 
	/// <li>If the proxy could not be created, a <seealso cref="StubNotFoundException"/>
	/// will be thrown.
	/// 
	/// </ul>
	/// 
	/// @implNote
	/// Depending upon which constructor or static method is used for exporting an
	/// object, <seealso cref="RMISocketFactory"/> may be used for creating sockets.
	/// By default, server sockets created by <seealso cref="RMISocketFactory"/>
	/// listen on all network interfaces. See the
	/// <seealso cref="RMISocketFactory"/> class and the section
	/// <a href="{@docRoot}/../platform/rmi/spec/rmi-server29.html">RMI Socket Factories</a>
	/// in the
	/// <a href="{@docRoot}/../platform/rmi/spec/rmiTOC.html">Java RMI Specification</a>.
	/// 
	/// @author  Ann Wollrath
	/// @author  Peter Jones
	/// @since   JDK1.1
	/// 
	/// </para>
	/// </summary>
	public class UnicastRemoteObject : RemoteServer
	{

		/// <summary>
		/// @serial port number on which to export object
		/// </summary>
		private int Port = 0;

		/// <summary>
		/// @serial client-side socket factory (if any)
		/// </summary>
		private RMIClientSocketFactory Csf = null;

		/// <summary>
		/// @serial server-side socket factory (if any) to use when
		/// exporting object
		/// </summary>
		private RMIServerSocketFactory Ssf = null;

		/* indicate compatibility with JDK 1.1.x version of class */
		private const long SerialVersionUID = 4974527148936298033L;

		/// <summary>
		/// Creates and exports a new UnicastRemoteObject object using an
		/// anonymous port.
		/// 
		/// <para>The object is exported with a server socket
		/// created using the <seealso cref="RMISocketFactory"/> class.
		/// 
		/// </para>
		/// </summary>
		/// <exception cref="RemoteException"> if failed to export object
		/// @since JDK1.1 </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: protected UnicastRemoteObject() throws RemoteException
		protected internal UnicastRemoteObject() : this(0)
		{
		}

		/// <summary>
		/// Creates and exports a new UnicastRemoteObject object using the
		/// particular supplied port.
		/// 
		/// <para>The object is exported with a server socket
		/// created using the <seealso cref="RMISocketFactory"/> class.
		/// 
		/// </para>
		/// </summary>
		/// <param name="port"> the port number on which the remote object receives calls
		/// (if <code>port</code> is zero, an anonymous port is chosen) </param>
		/// <exception cref="RemoteException"> if failed to export object
		/// @since 1.2 </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: protected UnicastRemoteObject(int port) throws RemoteException
		protected internal UnicastRemoteObject(int port)
		{
			this.Port = port;
			ExportObject((Remote) this, port);
		}

		/// <summary>
		/// Creates and exports a new UnicastRemoteObject object using the
		/// particular supplied port and socket factories.
		/// 
		/// <para>Either socket factory may be {@code null}, in which case
		/// the corresponding client or server socket creation method of
		/// <seealso cref="RMISocketFactory"/> is used instead.
		/// 
		/// </para>
		/// </summary>
		/// <param name="port"> the port number on which the remote object receives calls
		/// (if <code>port</code> is zero, an anonymous port is chosen) </param>
		/// <param name="csf"> the client-side socket factory for making calls to the
		/// remote object </param>
		/// <param name="ssf"> the server-side socket factory for receiving remote calls </param>
		/// <exception cref="RemoteException"> if failed to export object
		/// @since 1.2 </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: protected UnicastRemoteObject(int port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf) throws RemoteException
		protected internal UnicastRemoteObject(int port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf)
		{
			this.Port = port;
			this.Csf = csf;
			this.Ssf = ssf;
			ExportObject((Remote) this, port, csf, ssf);
		}

		/// <summary>
		/// Re-export the remote object when it is deserialized.
		/// </summary>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
		private void ReadObject(java.io.ObjectInputStream @in)
		{
			@in.DefaultReadObject();
			Reexport();
		}

		/// <summary>
		/// Returns a clone of the remote object that is distinct from
		/// the original.
		/// </summary>
		/// <exception cref="CloneNotSupportedException"> if clone failed due to
		/// a RemoteException. </exception>
		/// <returns> the new remote object
		/// @since JDK1.1 </returns>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: public Object clone() throws CloneNotSupportedException
		public virtual Object Clone()
		{
			try
			{
				UnicastRemoteObject cloned = (UnicastRemoteObject) base.Clone();
				cloned.Reexport();
				return cloned;
			}
			catch (RemoteException e)
			{
				throw new ServerCloneException("Clone failed", e);
			}
		}

		/*
		 * Exports this UnicastRemoteObject using its initialized fields because
		 * its creation bypassed running its constructors (via deserialization
		 * or cloning, for example).
		 */
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: private void reexport() throws RemoteException
		private void Reexport()
		{
			if (Csf == null && Ssf == null)
			{
				ExportObject((Remote) this, Port);
			}
			else
			{
				ExportObject((Remote) this, Port, Csf, Ssf);
			}
		}

		/// <summary>
		/// Exports the remote object to make it available to receive incoming
		/// calls using an anonymous port. This method will always return a
		/// statically generated stub.
		/// 
		/// <para>The object is exported with a server socket
		/// created using the <seealso cref="RMISocketFactory"/> class.
		/// 
		/// </para>
		/// </summary>
		/// <param name="obj"> the remote object to be exported </param>
		/// <returns> remote object stub </returns>
		/// <exception cref="RemoteException"> if export fails
		/// @since JDK1.1 </exception>
		/// @deprecated This method is deprecated because it supports only static stubs.
		/// Use <seealso cref="#exportObject(Remote, int) exportObject(Remote, port)"/> or
		/// {@link #exportObject(Remote, int, RMIClientSocketFactory, RMIServerSocketFactory)
		/// exportObject(Remote, port, csf, ssf)}
		/// instead. 
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: @Deprecated("This method is deprecated because it supports only static stubs.") public static RemoteStub exportObject(Remote obj) throws RemoteException
		[Obsolete("This method is deprecated because it supports only static stubs.")]
		public static RemoteStub ExportObject(Remote obj)
		{
			/*
			 * Use UnicastServerRef constructor passing the boolean value true
			 * to indicate that only a generated stub class should be used.  A
			 * generated stub class must be used instead of a dynamic proxy
			 * because the return value of this method is RemoteStub which a
			 * dynamic proxy class cannot extend.
			 */
			return (RemoteStub) ExportObject(obj, new UnicastServerRef(true));
		}

		/// <summary>
		/// Exports the remote object to make it available to receive incoming
		/// calls, using the particular supplied port.
		/// 
		/// <para>The object is exported with a server socket
		/// created using the <seealso cref="RMISocketFactory"/> class.
		/// 
		/// </para>
		/// </summary>
		/// <param name="obj"> the remote object to be exported </param>
		/// <param name="port"> the port to export the object on </param>
		/// <returns> remote object stub </returns>
		/// <exception cref="RemoteException"> if export fails
		/// @since 1.2 </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: public static Remote exportObject(Remote obj, int port) throws RemoteException
		public static Remote ExportObject(Remote obj, int port)
		{
			return ExportObject(obj, new UnicastServerRef(port));
		}

		/// <summary>
		/// Exports the remote object to make it available to receive incoming
		/// calls, using a transport specified by the given socket factory.
		/// 
		/// <para>Either socket factory may be {@code null}, in which case
		/// the corresponding client or server socket creation method of
		/// <seealso cref="RMISocketFactory"/> is used instead.
		/// 
		/// </para>
		/// </summary>
		/// <param name="obj"> the remote object to be exported </param>
		/// <param name="port"> the port to export the object on </param>
		/// <param name="csf"> the client-side socket factory for making calls to the
		/// remote object </param>
		/// <param name="ssf"> the server-side socket factory for receiving remote calls </param>
		/// <returns> remote object stub </returns>
		/// <exception cref="RemoteException"> if export fails
		/// @since 1.2 </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: public static Remote exportObject(Remote obj, int port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf) throws RemoteException
		public static Remote ExportObject(Remote obj, int port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf)
		{

			return ExportObject(obj, new UnicastServerRef2(port, csf, ssf));
		}

		/// <summary>
		/// Removes the remote object, obj, from the RMI runtime. If
		/// successful, the object can no longer accept incoming RMI calls.
		/// If the force parameter is true, the object is forcibly unexported
		/// even if there are pending calls to the remote object or the
		/// remote object still has calls in progress.  If the force
		/// parameter is false, the object is only unexported if there are
		/// no pending or in progress calls to the object.
		/// </summary>
		/// <param name="obj"> the remote object to be unexported </param>
		/// <param name="force"> if true, unexports the object even if there are
		/// pending or in-progress calls; if false, only unexports the object
		/// if there are no pending or in-progress calls </param>
		/// <returns> true if operation is successful, false otherwise </returns>
		/// <exception cref="NoSuchObjectException"> if the remote object is not
		/// currently exported
		/// @since 1.2 </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: public static boolean unexportObject(Remote obj, boolean force) throws java.rmi.NoSuchObjectException
		public static bool UnexportObject(Remote obj, bool force)
		{
			return sun.rmi.transport.ObjectTable.unexportObject(obj, force);
		}

		/// <summary>
		/// Exports the specified object using the specified server ref.
		/// </summary>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: private static Remote exportObject(Remote obj, sun.rmi.server.UnicastServerRef sref) throws RemoteException
		private static Remote ExportObject(Remote obj, UnicastServerRef sref)
		{
			// if obj extends UnicastRemoteObject, set its ref.
			if (obj is UnicastRemoteObject)
			{
				((UnicastRemoteObject) obj).@ref = sref;
			}
			return sref.exportObject(obj, null, false);
		}
	}

}